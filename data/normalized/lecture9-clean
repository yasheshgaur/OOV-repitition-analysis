Programming Paradigm-Lecturezeronine

Instructor (Jerry Cain):Hey, everyone, we are online. I do not know have any handouts for you today. I started to introduce the next segment of the course as being the part where we actually cover computer architecture and assembly language. We are gonna spend a lot of time trying to figure out exactly what our C and C plus  plus  code snippets, or just the C and C plus  plus  code, although we will only deal with snippets in any one example, how it actually compiles to assembly code. Talk a little bit about the memory the models, talk a little bit about how function call and return works, and also to expose you to, not a real assembly language, but at least a little mock one that we have invented for CStenseven purposes to kind of show you all of the little gears that are in place to get addition and multiplication and division and function call and return and pointers, and all those things to actually work, but at the hardware level. Okay? Now, when I left you last time I had started talking about the stack segment. And if you remember, probably about halfway through Friday is lecture I had hexagons and circles and triangles as placeholders for basically the skeletal figures that overlaid memory, and showed you how all the local variables in a particular function were actually packed together in what was called an activation record. In many ways, the assembly code that we are going to be writing, are really just these four-byte instructions. They are ultimately zero is and one is, but they are interpreted by the hardware to access variables within the triangles and the hexagons, okay, and pull them into registers. Maybe add one to them, or add ten to them, or pass it to some helper functions just to get the assembly code to imitate exactly what your C and C plus  plus  code was written to do. Okay?

So here is the stack segment. Let me just contrive this one little block of code. All right, int i, I have int j, and then I do i is equal to ten. And then I do j is equal to i plus seven, and then I will do j plus plus. Let is just assume, not surprisingly, that i and j are packed together as some eight-byte activation record and they reside somewhere in the stack segment. I am just gonna draw it randomly right here. Okay? And that address right there, I am going to assume, is stored in one of those thirty-two registers that I named last time; I am just going to go with the first one and call it Rone. So Rone is a general purpose four-byte bit pattern storer that actually happens to store the base address of the activation record that makes up this code snippet. Okay? Now, you ultimately know that a ten has to be placed there, and that an eighteen will eventually go there. Okay? Does that make sense to people, I am assuming? Okay. But I actually am more focused not on the numbers themselves, as the assembly code that actually does that relative to this address right here. So I am going to make some assumptions that the base address of the two variables that are relative here, are stored in a special dedicated register. I am going to call it Rone now; I will change the name in a little bit. And I am just gonna illustrate by example what assembly code instructions look like to actually put a ten right there, and then to pull it into a register, add seven to it and flush it back out to the space for j. Okay?

In order to get a ten into that space right there, we do not actually deal with that address specifically, we just deal with an address that is at an offset of positive four from the address stored right there. Okay? The notation for doing this, this one line in our little mock assembly language would compile to that. And that is our first assembly code instruction. Okay? That capital M, it is like it is the name of all of RAM. You think about all of RAM as this big array of bytes, M is the name of that thing, Rone is the base address, four is an offset. This right there identifies the base address of the four-byte figure in all RAM that should get a ten. Does that make sense to people? Okay. So this is an example of a store operation. And it is called a store operation because it actually updates some region in a stack segment with some new value. The very next few instructions are in place to actually take care of j is equal to i plus seven. I do not want to bank on the fact - or rely on the fact that I know because of this small example that i is equal to ten. I wanna do the most robust thing, which is to actually go and fetch the value of i, pull it into a register where you are allowed to do addition, added a seven to it, and then flush the result out to M of Rone. Does that set well with everybody? Okay.

So do not bank on the fact that there happens to be a ten right there. An optimizing compiler might take an advantage of that, but we are not writing an optimizing compiler, we are just trying to brute force without the translation process right here. I wanna do this: into Rtwo, another general purpose register, I wanna load the four-byte bit pattern that happens to reside right here. Now, this is an example of a load operation. Okay. Let is make it so that that really looks like a load. Rtwo contains the four-byte bit pattern for what is residing in i right there, so this corresponds to the understanding that we are going to operate on i is value. Into Rthree, another general purpose register, I am going to take whatever Rtwo has as a bit pattern and add the immediate constant seven to it; this is an ALU operation. It is actually very often the case, though, on the right hand side of some ALU operation, there are either two registers, or there is a single register and a constant, and that wherever the result is to be stored is identified on the left hand side. Okay. That probably makes sense to people. This is a bit pattern, is the thing that has to be replicated in the space that is really set aside for j, and we know where j is because we have Rone storing the base address of it. So right here, I have yet another store operation. So two of the registers, Rtwo and Rthree were piecemeal updated with a ten right there, a seventeen right there, and then a seventeen is flushed right there. Okay. Does that make sense to people?

This load ALU store sequence is actually very common, and exists more or less on behalf of any kind of assignment-oriented statement in C or C plus  plus . Okay? The very next line really expands to j is equal to j plus one, so it has a structure that is very similar to this. I can reuse registers. I can even discard a temporary value that is in Rtwo if, for whatever reason I want to. I do not have to write to Rthree right there, and then I can do M of Rone is equal to the new value that ended up in Rtwo. Okay? I did not have to be that efficient about the user registers, but it is not a problem if I do not need the old value of j and I just want to deal with the incremented value. It is fine to overwrite Rtwo, and to override its old value. So this has the same exact structure as that right there, it just happens to be dealing with variable in RAM as opposed to two, and this is how this seventeen goes from an eighteen, and Rtwo would also have an eighteen inside of it. So a few things to say about this, by default all of the load and store and ALU operations deal with four-byte quantities. Okay? It is clearly the case that pointers and ints are probably by far the most common atomic type you deal with in programming, at least in C and C plus  plus , so the hardware is set up to optimize, by default, dealing with four-byte figures. Okay. That does not mean we cannot deal with isolated characters and shorts, or that we cannot deal with doubles and structs as a whole. But I am more interested in being four-byte oriented with all of my instructions here. Okay.

A lot of you may be questioning why I bother to do this. You could say, "Well, why do not I just set Rthree equal to ten plus seven?" I want to - every single one of these blocks - this corresponds to that statement, these three correspond to that statement, these three correspond to that statement. I want every single block of assembly code instructions to be emitted or rendered in this context insensitive manner. And the reason I am saying that is because this code is going to work out and do the right thing even if I change this line right here. Do you understand what I mean when I say that? Okay. If I were to hard code in an M of Rone is equal to seventeen, then that would stop being correct if I changed this line, which was supposed to be completely unrelated to it - to, like, a twelve or a one hundred. Okay? Does that set well with everybody? Okay. The same thing with this. You could argue, "Well, why do not I just go in and do M of Rone  plus  plus ?" R assembly code instruction does not allow ALU-like operations to be performed on arbitrary memory addresses. You always have to go through the load, do an ALU operation on just registered values, okay, and then flush the result back out to memory. It more or less makes for a simpler assembly language, and it also makes for a faster clock speed when things are that simple. Okay. Make sense to people?

Let is deal with an example that actually does not always deal with four-byte quantities. Let me go ahead and do int i car ch - actually, I do not want to do that - [inaudible]. Let is do short Sone short Stwo. Okay. The way I have declared these, we would be dealing with an activation record that looked like this: i is right there; this is where Sone is gonna be declared, this is where Stwo is gonna be declared. Okay? That looks a little weird, but Stwo is the last of the three declarations, and so it is gonna be at the lowest base address according to my model. Okay. I am always gonna give you variable declarations that work out nicely and that are an even multiple of four-bytes so that the pictures are always fully rectangular and with no, like, chunks or nips out of the corners. If I do this, that is more or less the same as that instruction up there, with a different number. This would translate to M of Rone plus four, assuming that the register Rone has been set to point to that right there. Rone plus four, memory [inaudible] reference is equal to two hundred. Okay. That means as a four-byte figure, the bit pattern for two hundred is laid down. Now, two hundred is a pretty small number, so in a big ending world, we would expect one byte of zero followed by another byte of zero, followed by a third byte of zero, followed by one byte that happens to have all of the two hundred in it. Does that set well with everybody? Okay. This line has to somehow update Sone - let is actually write it, to be equal to, logically, two hundred. But it is only supposed to update two bytes of memory. Does that make sense? Well, if you wrote this, your heart would be in the right place, but there are two fairly relevant errors going on here. First of all, you cannot do a load and a store in one single operation. Okay. Because that would require assembly code instructions to somehow encode in four bytes the source, memory address, and the destination memory address, and that is difficult to do. So what we wanna do is we want to evaluate i as a standalone expression, and just do this: Rtwo is equal to M of Rone plus four, again I am being context insensitive about it.

That means that Rtwo is gonna have that as a bit pattern inside of it. And then what I want to happen is I somehow want to update this two bytes right here with the two hundred, but I only want those two bytes to be copied. That is consistent with what we know happens just at the C and C plus  plus  level. Okay. Now, if I do this, that will not do what we want because the assembly code that I am writing right there has absolutely no memory as it is executing what C or C plus  plus  code was in place to generate it. And the way I have written it right there, it is just like so many other operations I have put up here. This would be taken as an instruction to update the four bytes from this address through this address, plus three, okay, with new information. And it would update that and that and that and that with four new bytes. Does that make sense to people? I do not want that to happen. This instruction right here would put a zero and a zero and a zero and a two hundred right there, and then all of a sudden, Sone would be initialized to zero, and i would become some very, very large number. Okay? That is because I am mistakenly dealing with a four-byte byte transfer here and I do not want that. In our world, you override the four-byte rule by actually putting a little dot-two right there. It is as if all of these other instructions have an implicit dot-four, but we do not bother writing dot-four because dot-four is just for the default. But when you only wanna move around a single half-word, which is two bytes, or a single byte, you would put dot-two or dot-one there. Okay? That is an instruction that when we are sourcing from a register, so just take the lower half of it and update the two bytes that they give in this address right here. Okay? And update this with zero and two hundred, and that is how Sone becomes two hundred, and that is how i is left alone as the two hundred is a four-byte quantity. Okay? Does that make sense to people? Okay. If I do this, Stwo is equal to Sone plus one, it is very similar to the j plus  plus  up there, but we have a lot of dot-two is that are in place to make sure that only two bytes are moved around at any one moment.

This right here would have to load Sone into a register. This is how I would do that: Rtwo is equal to M - whoops - M of Rone plus two. But the way I have written it right there, it will copy four bytes as opposed to two bytes, unless I do this. What that does is forget about the old value and set Rtwo. When it pulls two bytes into a register, it lays these two bytes in the lower two bytes of the entire register, and then it sign extends it just like it would in C and C plus  plus . So it is padded with two bytes of zero is right there. Okay. Now this plus one is just traditional plus one. Rthree is equal to Rtwo plus one; that is what takes this to be two hundred to two hundred and one. And then when I flush the result out to this other space that has just two bytes associated with it, I do it this way: M of Rone equals dot-two, the result that is stored in Rthree. Okay. So I understand that these examples are not all that riveting from an algorithmic standpoint, I am really just trying to illustrate our assembly code languages as operations on general memory where the general memory is framed as an array of bytes, but everything is taken in four-byte chunks, by default anyway. Okay. Yep, go ahead.

Student:

Is there a reason why you used a third register in that last -

Instructor (Jerry Cain):

As opposed to there, no.

Student:

- second one?

Instructor (Jerry Cain):I actually - I am inconsistent with my use of registers, in terms of, like, the conserving. I just conserve them if I anticipate having a lot of them in the example. I just did it there, I should have put Rtwo. I thought of that as I was writing it. Okay. Any other questions at all? Yeah?

Student:

What is the [inaudible]?

Instructor (Jerry Cain):M of Rone identifies this space right there; that corresponds to Stwo. Okay. So that is receiving some two-byte bit pattern because of that dot-two right there. Does that make sense? Rthree stores the incremented value, or the result of the plus one operation that is right there. So a full evaluation of the right-hand side ultimately made it into Rthree. I only have room for the bottom two bytes, which is why I have that dot-two right there. Okay. So this is how I get zero, two hundred and one right there. Okay.

Now there are other things that go on, but as far as - interestingly enough, except for function call and return, you have seen almost all the mechanics of the assembly code language that I want to teach you. Okay.

Let me do this, let me deal with an array of length ten - no, actually that is too big. An array of length four is big enough, and then I have a standalone integer. And I just wanna go ahead and figure out what this four loop will translate. And with each iteration, I just wanna update some value in the array to be equal to zero. After it is all over I wanna set i minus minus.

Just to say something silly right here, do you understand how this code is simple enough that it is just executed sequentially? The assembly code is executed in sequence as well. First clock cycle it updates memory according to that rule right there; next clock cycle it does that and then that and then that and that and that and that. And over the accumulation of six clock cycles, we have effectively realized these three C statements. Memory is updated in a way that is consistent with the way these three lines have been written. Okay.

There is some looping going on there, clearly. If there is looping in a language, then you should not be surprised that there are at least directives in it in the assembly code language to jump back an arbitrary distance to start over some loop again. Okay. Or with the case of, like, if statements and switch statements; they are based on the result of some test, you actually jump forward four instructions or twelve instructions to the point it starts executing the else clause or some particular case statement. Okay. Does that make sense to everybody? Okay.

So as I write this, I should write assembly code, and you are familiar with how that and that would be executed, maybe to some degree that, as well, although you have not seen a raise in the context of assembly language, but the test is new to us. The i minus minus is not, but the actual looping certainly is.

You know how there are six different relational operators that can be set in between any two integers? Less than, less than or equal to, greater than, greater than or equal to, double equals, not equals to. It is typically the case in most assembly languages that they have branch instructions that are guided by the same six types of relational operators. Okay.

Let me just write the code for this. Let me draw the picture; the way this would be laid out is that I would have sixteen bytes with four more bytes below it, that is I, this is array of zero through three, but I will emphasize that this is the zero, the oneth, the twoth, and the threeth. Okay. And assume that Rone points to the base address of the entire figure. The actual hardware will make sure that the base address of the currently relevant activation record - that that address is stored in some register; I just happen to be calling it Rone at the moment. Okay.

So we come here. We assume that Rone, as a register, stores the address of that picture up there. And the first thing that happens, is that this thing gets executed exactly once because it is in the [inaudible] portion of the four-loop, obviously. So what happens is that right up front, M of Rone is set equal to zero. And that gets a zero right there. Okay.

We next execute code on behalf of this to decide whether we are going inside the body of the four loop, or we are circumventing it because the test failed. Okay. These are the assembly code instructions that would be expanded on behalf of this test right there. I will put a double line right there to mean that there is some new C statement that we are dealing with.

I would have to load into Rtwo the value that is at M of Rone. Okay. Again, I am starting to generate code in a context insensitive manner, I do not want to assume that there is a zero in there. In fact, you will see in a little bit that there will not always be a zero in M of Rone. So I wanna load that into a register, and then I have this branch instruction, b, and I am gonna leave a blank and a blank right there. We are gonna fill this in with some abbreviation for not equals or greater than or equal to or whatever. We will decide what it is in a second. It takes three arguments. It takes - whoops - the first register in the comparison or constant, the second register in the comparison or a constant, in this case it is four; and then it takes as a third argument what is called a target address, the place to jump to if the branch instruction passes. Okay. Now we jump forward several instructions - I am sorry, let is say one C instruction here if this test fails. But if I take the logical and inversion of this, and I jump forward when this test passes, okay, then I am circumventing the four loop. Does that make sense to people? This is where code for the array of i equals zero will be placed. When this test fails, this test needs to pass so that I jump forward a certain number of assembly code instructions to the part that actually executes that right there. Okay. That means that I want to branch, I want to circumvent the normal pattern of advancing to the next assembly code instruction if this as a number is greater than or equal to four. Okay? And so the abbreviations for these branch instructions should not surprise you; they are: branch on equal, branch on not equal, branch on less than, branch on less than or equal to, branch on greater than, branch on greater than or equal to. Okay. So if Rtwo, which stores the current value of i is greater than or equal to four, we know the loop is over, so we wanna jump forward as if the loop never existed before. Okay. We have to fill this part in. All I can tell you right now is that the address here is gonna be framed as some offset relative to a special register I call PC. Now, PC is really gonna be like the twenty-seventh or the twenty-nineth or the thirty-onest of the thirty-two registers, we just give a better name for it. PC stands for program counter, and it stores the assembly code instruction of the currently executing instruction. Okay. I am sorry, it stores the address of the currently executing instruction. We never know what PC really is, but if this is PC, this is PC plus four, PC plus eight, PC plus twelve, PC plus sixteen, et cetera. Does that set well with everybody? And with each clock cycle, as part of each clock cycle, it by default just updates PC to be four larger than what it was before because all of our assembly code instructions are four-bytes wide. Okay. And by default, it always just advances to the next one unless some jump instruction or some branch instruction like that tells us to do otherwise. Okay. I am leaving a question mark right here because I just do not know how many lines array of i equals zero is gonna translate to. Okay. All I can tell you right now is that the offset is gonna be positive, and that it is going to be some multiple of four. So something like plus sixteen or plus twelve or plus twenty-four, we have no idea what yet. Okay.

If this branch instruction fails, it is because this test passed which means I would have to just fall right to the next line of C code, which means I would have to fall to the next line of assembly code, which implements this right here. Okay. Now you know enough about pointer math, this is easy pointer math. But this has to translate at the assembly code level to something that finds the address of the ith figure in the array and writes a zero there. There is implicit scaling of i times size of integer here; does that make sense? The scaling over here has to be explicit. Okay. If you just write assembly code by hand, which you can do, and you are just really thinking in C and C plus  plus  terms while you are doing it, you have to make sure that you assign to an offset of plus zero or plus four or plus eight relative to the base address of the array when you are writing a zero. If you are trying to emulate a four loop inside assembly code, then you have to make sure you take care of the pointer math explicitly. So what I wanna do is I want to reload the value of I because I am being context insensitive about how I use variable values. It is a zero, a one, a two, or a three; we know that. But then what I wanna do, is I wanna take Rthree and I wanna multiply it by four. Now that four is there because ints are actually four bytes. I cannot write size of int here like I encourage you to, not in this example but whenever you have to manually deal with type sizes in C and C plus  plus  code because this has nothing to do ultimately with C or C plus  plus . Okay. It happens to be imitating the execution of a C plus  plus  program, but all size and type information at the assembly code level is completely gone. It just has to be the case that the code is written in a way that is consistent with this is intended to do. Okay. Rthree has the value of i, Rfour has the value of i scaled by four, so now Rfour has the distance in terms of bytes from the base address of array to where the zero has to be placed. Does that make sense? What is the value of array? We know that it is ampersand of array of zero, right? Array of zero resides right here. Okay. So the ampersand of array of zero, which is synonymous with just plain old array, it is synonymous with Rone plus four. So I am gonna do this. This stores the offset; this stores the base address of the entire array. Rsix is equal to Rfour plus Rfive - whoops - Rsix has the address within the array that should get a zero on this particular iteration. Okay.

Every single iteration - Rfive gets the same value every single time, but Rfour certainly does not. So that means that M of Rsix is equal to - I am sorry, M of Rone - oh, no, I am sorry, that is right. Rsix is equal to zero; that is the base address of the place in the stack activation record, that should get the zero and that is why a zero was there. These five lines right there, it is complicated, but they actually are in place to emulate that line right there. If we were writing a CSone hundred and seven assembly language compiler, this line would translate to these five lines or something that is equivalent to it. Okay. Then what happens next unconditionally, is that we jump back up here to i plus plus, and we execute this. That just does this - Rtwo is equal to M of Rone; Rtwo is equal to Rtwo plus one; M of Rone is equal to Rtwo. And then we know that we execute the test again. So what happens here? Rather than actually writing the code for the test again, you go back and you reuse the same code you wrote for it the first time. So this is an unconditional branch. Okay. We do not use the word branch, we just use jmp because they did not have room for the u - jmp, and you actually jump to a hard-coded address, but we always frame it in terms of the current PC value. So it is not PC itself, it is PC minus some value. I wanna jump back to this line right here; the line that loads i, compares it to four and decides what it is gonna do. Okay? This minus has to be scaled by four, but I wanna jump back one, two, three, four, five, six, seven, eight, nine, ten instructions. Does that make sense to people? So this would be a PC minus forty. Okay. Right here, I am out of room, but this is where I would continue. This is where the code for i minus minus would go, and it would be assembly code that is emitted for i minus minus that has nothing to do with this four loop. And it does not bank on the fact or the understanding that I would be equal to four at the time it gets there, it would just do the Rtwo is equal to M of Rone; Rtwo is equal to Rtwo minus one, and then flush it back out to i. The reason I am writing that there and the reason I have this here is because I wanna make it clear that this is the place where we should be jumping forward to at the assembly code level when that test passes. Okay? When this test fails, I just do the implicit update of PC to PC plus four. You do not have to write anything for that that just happens by default. If you wanna override what gets used as the new PC value, you have to set PC right here to be PC plus one, two, three, four, five, six, seven, eight, nine, ten instructions. Okay. Times four, so this question mark would become a forty. Okay? Do you guys understand why those numbers are forty?

You may think that this minus value right there and that plus value there have to be exactly the same, that is not always the case. Okay. It just depends on how complicated the test is, but sometimes this right here, which is the part that evaluates the i, this could be something that is arbitrarily complicated, like i plus twenty-four plus j or something like that. So it might actually be a lot of code that would have to be accounted for in this jump right here. Okay. But this plus forty deals with an offset from this to the line after the unconditional jump back; it may be a smaller value. Okay. So they are not always the same number. Okay. I think you understand, even if the assembly code is weird for you at the moment, you understand that it really is this brute force translation of this right here to code in a language that just thinks about moving four-byte quantities around by default. Okay. Short action branch instructions, it has some unconditional branches and some conditional branches. There are gonna be a few more things in place, but really you have seen like seventy percent of the language already. Okay. You guys get what is going on here? Okay. Very good. Questions? Yeah, right there.

Student:If you wanted to, instead of jumping back ten lines, could you just jump back nine because the top line is Rtwo equals MRone and you [inaudible] right before the jump set MRone equals Rtwo?

Instructor (Jerry Cain):Yu could. It actually - it would certainly be correct in the sense that it would do the right thing. That would just be taking advantage of the fact that the register happens to have the right value, but I just wanna be consistent. I am not going to enforce this - I am not gonna police the matter to the point where I actually yell at you about it, but I would actually like you to just get in the habit of generating code in this context insensitive manner. And this load right here, this one happened to do with the fact that there is an i present in the test; does that make sense? This i - I am sorry, this Rtwo being set to that right there, okay, just happens to be associated with this i plus plus right here. And as it turns out, actually - I am sorry, this right here has the right value. It is - I do not want to say it is a coincidence, because it is not a coincidence, it is a four loop and it is the traditional idiom with the four loop. But I would rather you just be fastidious about just generating it and, like, basically going brain dead about what you have generated code for before because then you know you are always right, okay, regardless of whether or not this changes.

You want the code that is emitted on behalf of this right here and that right there to be the same every single time, or at least allow it to work if it is the same every single time, regardless of what you do right here. Okay. Yeah?

Student:If all of the translations of every single translation translates into thirty-two bits -

Instructor (Jerry Cain):That is right. We are dealing with assembly code language where all instructions are four bytes wide. Okay. Thirty-two bits, all of them, yeah. Okay.?

Does that make sense to people? Okay. Let me explain a little bit how thirty-two bits are usually just enough for you to encode an instruction, just to understand what encoding is like. When a four-byte figure is understood to be an assembly code instruction, it is typically subdivided into little packets or little sub-packets. Here is a four-byte instruction, and I will just draw very loose boundaries here for the bytes. We are used to instructions like this: Rone is equal to M of Rtwo - I am sorry, M of Rtwo plus four. Something like Rone is equal to a constant is not unusual either. Maybe you see something like this: Rthree is equal to Rsix times Rten. And then something like M of Rone minus twenty is equal to let is say Rnineteen. A load, a direct immediate constant load, an ALU operation, and a store; these are little bit more elaborate than you would see in practice, but nonetheless we have to be able to support them.

This type of instruction and that and that, they are certainly different from one another. This is a load, this is an ALU operation, this is a store. You understand what I mean when I say that. I even argue that this right here is technically a different type of instruction than this one because this is framed in terms of a register and an arbitrary memory address, and this is framed in terms of the constant. Does that make sense?

Let is say that I have decided that my assembly code language has let is say - let me - fifty-nine different types of instructions. I have to somehow encode in this four bytes right here, which of the fifty-nine instructions we are actually dealing with. Does that make sense? Well, fifty-nine, unfortunately, is not a perfect power of two, so if I really want to be able to distinguish between fifty-nine patterns, I have to be able to distinguish between, it turns out, sixty-four different patterns, okay? So I might set aside the first six bits of all thirty-two bits of - of all thirty-two of them to be the part that the hardware looks at to figure out what type of instructions should be executing. Maybe it is the case that this corresponds to - in this space right here would be called an operation code, or an op code; maybe it is the case that all zeros means this type of load instruction. Maybe this right here is the op code for an immediate constant load into a register. Maybe this right here, being a multiplication, corresponds to that type right there, and then that right there might be let is say all ones. Does that make sense to people?

When the hardware looks at an assembly code instruction, it does not actually see these. This is an assembly language instruction that makes sense to us, but it is actually expressed in the hardware as a machine code, which is thirty-two zeros and ones. It would actually have to look at the first six during the first few percents of the clock cycle, okay, to figure out how to interpret the remaining twenty-six bits. Does that make sense to people? Okay. Maybe this is the type of instruction that allows any one of thirty-two registers to be updated; it allows any one of thirty-two registers to be the base right there, and then it allows all of the other bits to express this as a signed constant. Do you understand what I mean when I say that?

Okay. There are thirty-two possibilities for this, there are thirty-two possibilities for that, and there is however many possibilities are allowed based on how much room we have left to encode that, we would need five bits to encode which register gets the update, five bits which determines the base address and the memory offset. And then maybe it is the case that all the remaining bits, in theory, hardware - people who actually still believe would laugh at this, but in theory, the remaining whatever sixteen bits could be used to express a signed offset from this right here. Okay. And I draw this subdivision of five and five and sixteen right there. That subdivision is only relevant when the first six bits happen to contain all zeros. Does that make sense to people?

For this right here, all I would need to do is set aside five bits. If it read zero, zero, zero, zero, one right there, then it would say, "Oh, you know what? The hardware is implemented in such a way that when there is all zeros followed by a one right here, that the first five bits tell me which of thirty-two registers I am assigning to, and all of the remaining bits, all twenty-one of them, can be expressed a signed integer that actually gets put into that space." Okay. So the subdivision scheme from bit seven forward actually depends and how it is interpreted depends on what the op code says.

Now ultimately what happens at the EE level is that these are all taken as instructions as to how to propagate signals through the hardware so that the signals at the beginning of the clock cycle look like the ones and the seventeen is and the ten is and the two hundred is that we have dealt with in the prior examples. Okay. That is the extent of my understanding of EE, the way I just said that. Okay. But you get the principles of what I am trying to say, right?

Okay. What else did I wanna say? There is absolutely no requirement that all op codes be exactly the same size. You all did - a lot of you did the - I am sorry, there is this one assignment that we use in one hundred and sixX called the Huffman encoding assignment. Those who have heard about it know about it. one hundred and sixB does not do Huffman encoding do they? Okay. Well, that is an example where they actually have variable length encodings. Here we have a constant length encoding for all op codes. It could be the case that one of the op codes could just be this right there. Okay. And then some other op codes would have to be longer, so maybe this is another op code. It would only require that the first three bits do not happen to be coincidence if it is something that could be interpreted as a three-bit op code. Does that make sense to people? That may seem like a silly thing to do, except that this might be the type of instruction that benefits from having lots and lots of bits set aside for some unsigned integer offset. Okay. Or it might be the one that is most popular so it wants the most flexibility in how it expresses its arguments. Okay. I do not wanna say that this is not common; I think it actually is common. It certainly comes up in Nips which is the assembly code instruction that EE is study in EE one hundred and eightB, I think it is now, and CS majors currently have to as well. Okay. I am just gonna assume for all of our examples that this is the case, that we have constant op code lengths just because it is simpler to just rely on that type of information. Okay? Does that make sense to everybody? Okay. So there are a couple things I can do in the final six minutes. Before I start talking about function call and return, which I will get to on Wednesday, I should talk a little bit about structs, but more importantly, I should talk about pointers and casting. That is the part that makes C hard, but somehow compiles. And when it compiles, it means it compiles to something like this, but in - not in CSone hundred and seven assembly language, but like in Xeighty-six or whatever, or, like, Nips or whatever the target language happens to be.

Let me do one example here that is framed in terms of the struck fraction we dealt with lecture three or four. Struct traction int, num, int, denom, and that is it. And I declare a struct fraction called pi, and I do this: pi dot nu is equal to twenty-two. The way I told you that structs were laid out in the third or fourth lecture, that is actually true on virtually - in any architecture that I know of. That the structure packed - that the first field is at the lowest address and everything is stacked on top of it. And if I declare this one variable so that this is logically functioning as my pi variable, then Rone, in our world at the moment, stores the base address of the one variable that is there. But the one variable actually knows how it is decomposed into smaller atomic types. Okay. When I do this, not surprisingly, this actually translates to M of Rone is equal to twenty-two. If I do this, pi dot denom is equal to seven, I get M of Rone plus four is equal to seven. So that is easy, except for the fact that you are dealing with structs and you have to understand that the assignments have sort have forgotten about the structs and just are really updating individual integers inside the struct. The part that is interesting, transition to slightly more scary stuff, is if I do this ampersand of pi dot - let me rewrite this. Ampersand of pi dot denom, if I write it that way and then I cast it to be a struct fraction star, I will abbreviate there, and then I do this. Forget about the assembly code for a second, you know how memory is supposed to be updated; it is a little weird to see this type of thing, but it is irrelevant that it is weird because it is a legal C code, and it is supposed to compile to something. This says, "Identify the l-value of pi dot denom." Where is it located?" Okay. Stop pretending it is a standalone int and think that it is a base address of an entire fraction, go to its ghost denom field and put a four hundred and fifty-one there, okay?

The order at which things are kind of realized here, is it discovers this, it evaluates that address, it casts it to think that that right there is the base address of not a standalone int inside a struct, but the base address of an entire struct fraction, and a four hundred and fifty-one needs to be placed there. Okay. What assembly code instruction, there is only one of them that is needed, what is the assembly code instruction that would need to be in place in order for that four hundred and fifty-one to be placed there? It just translates to this. Now you may think I am cheating there and I am actually doing work, but this right here is understood to be an offset of four from Rone; the address is four beyond to that base address. Just because I cast it to be a struct fraction star does not change the value of the address, it just has a different idea as to what is at that address. It is like the compiler puts on a different set of glasses all of the sudden when it is looking at this one address right here, and it knows that at the denom field that you would get by de-referencing this, "Oh, it is a struct fracture because it says so," it is an offset of four beyond what it was already an offset from, Rone, and then it puts a four hundred and fifty-one there. So all the energy that is in place to compile this, either by hand or by code if you wanna write your own compiler, it actually can discover that this is really referring to an integer that is presumably at an offset of eight from Rone, which is where pi originally lives. Okay. Does that set well with everybody? So the cast - when you put a cast in place, at least in pure C code, there is no assembly code instruction that gets generated as a result of the cast operation. All the cast does, is it allows the compiler to generate code that it otherwise would not have been able to generate code for because it is like taking a little permission slip to behave differently, okay? Does that make sense? It wants to trust that there really is some legal interpretation associated with the code that it will emit by seeing that struct traction cast right there. Okay?

These are the types of things that exist in the assembly code that is generated by your IMDB get methods and get cast class. The C plus  plus  turns out it is not that much more than C in terms of compilation. Okay? You are doing all these void star and car star casts inside assignment three; either you have or you are going to very shortly. The same type of thing happens as it is compiled to either Xeighty-six or spark assembly, which is one of the two things you are dealing with if you are on either of the pods or the [inaudible], okay? Does that make sense to people? Okay. I can get arbitrarily complicated with all of these casts. You know I am the type of person that will be arbitrarily complicated with them, so you will see some examples of these in a section handout for next Tuesday, and also in the problem set assignment that will go out not this Wednesday, but next Wednesday. It will be your final assignment before the mid-term, okay? Or I want you to just master this pointer stuff. And believe it or not, you get a lot of mastery by actually coding with it, but if you are forced to draw pictures and generate code and make sure that the code you write down is assembly code, logically matches what mine and the answer key does, it actually resolves any remaining mysteries that might be in place in spite of the fact you get assignment two and assignment three working. Okay? There is still some mysteries that are in place for a lot of people and this usually resolves those mysteries. Okay. Come Wednesday I will do one more intense example with a little bit more casts; I will probably bring in an old exam problem and show you how fun they can be. And then we will move on to starting to understand how function call and return works at the assembly code level, how we introduce the hexagons and the circles to the stack frame and how we get rid of them. Okay. I will see you all on Wednesday.

End of Audio

Duration: fifty-two minutes



