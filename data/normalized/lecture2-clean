Programming Paradigm-Lecturezerotwo

Instructor (Jerry Cain):Hi, everyone. Welcome. I have four super handouts for you today. If you have not gotten them yet, feel free to just sit down. We are gonna probably make it a point because there is so many people in the class to just hand them out while I start lecturing. This way we do not have this big bottleneck of people trying to get in by eleven:zerozero. The four handouts are posted to the web page. The mailing lists were created last night. And I just looked at it this morning, and there were two hundred and forty-five email addresses on it. So it looks like it is working. I have not sent anything to the email list yet, but I will just contrive a message later this afternoon, and send it to everybody. And if you do not get that by Monday morning, when I make an announcement saying, "If you did not get that message let me know," then I will investigate as to why you are not on it. SEPD students, I am not sure that you are actually on the mailing list yet. That system runs a little bit differently, and usually they push your email address onto the mailing list a little bit later. I am not sure why, but - so if you do not get an email over the course of the weekend, then just let me know. And I will see what I can do to fix it. I will also post announcements to the web page so that you at least can get them. What I want to do is I want to start talking about the low-level memory mechanics, so that you understand how data - things as simple as Booleans and integers and floating-point numbers and strucks and classes - are all represented in memory. It is very interesting, I think, to understand how everything ultimately gets represented as a collection of zeros and ones. And how it is faithfully interpreted every single time to be that capital A, or that number seven, or Pi, or some struck that represents a fraction, things like that. And we will just become much, much better C and C plus  plus  programmers as a result of just understanding things at this low of a level.

So, for the moment, C and C plus  plus  are the same language to me. So let is just talk about this. Let me just put a little grid up here of all the data types that you have probably dealt with. You have probably dealt with boole. You have probably dealt with CAR. I am sure you have. You may not have dealt with the short, but I will put it up there anyway. You have certainly dealt with the int. You have certainly - well, maybe not dealt with the long, but let is just pretend you have. You have probably seen a floats. You have probably seen doubles. And that will be enough for me, enough fodder for the first ten minutes here. These three things - I am sorry. These three things right there are certainly related. They are all intended to represent scalar numbers. Obviously, this represents a true or a false. This represents in our world one of two hundred and fifty-six characters. We usually only pay attention to about seventy-five of them, but nonetheless, there are two hundred and fifty-six characters that could be represented here. These are all numeric. These take a stab at trying to represent arbitrarily precise numbers, okay? The character is usually one byte in memory. At least it is in all C and C plus  plus  programmers - program compilers that I know of. This is typically two bytes. The int can actually be anywhere between two and four bytes, but we are going to pretend in this class that it is always four bytes, okay? The long, for the time being, is four bytes of memory. There is another data type, which is not really common enough to deserve to be put on the blackboard, called the long long, which gives you eight bytes of memory to represent really, really large decimal numbers. They will come up later on, but I will talk about them if I ever need to. The float is four bytes. It somehow tries to take four bytes of memory and represent an arbitrarily precise number to the degree that it can, given that it is using a finite amount of memory to represent a number that requires and infinite amount of precision, sometimes. And a double, I have seen them ten and twelve bytes on some systems, but we are just gonna assume that they are eight bytes. Now, that is the most boring spreadsheet you could possibly introduce a class with, but my motivation is that I want to uncover what the byte is all about, and how four bytes can represent a large frame of numbers, how eight bytes can represent a very large set of numbers, and actually do a pretty good job at representing numbers precisely enough for our purposes.

So forget about bytes for the moment. Now, I will go back to the boole in a second, because it is kind of out of character as to how much memory it takes. But I am interested, at the moment, in what is less commonly called the binary digit, but you have heard it called the bit. And Double E students and those who enjoy electronics think of the binary digit in terms of transistors and voltages, high and low voltages. Computer scientists do not need to view it that way. They just need to recognize that a bit is a very small unit of memory that can distinguish between two different values. Double Es would say high-voltage, low-voltage. We do not. We actually just assume that a single bit can store a zero or a one. Technically, a Boolean could just be mapped to a single bit in memory. It turns out it is not practical to do that. But if you really wanted to use a single bit to represent a Boolean variable, you could engineer your compiler to do that, okay? Bits are more interesting when they are taken in groups. If I put down eight bits here - I am not even going to commit to a zero or a one, but I am gonna draw this. This is not zero over one as a fraction, this is me drawing eight bits - let me just draw one over here so I have some room - and put a little box around each one of them in this binary search way, okay? And I have this big exploded picture of what we will draw several times to represent a single byte of memory. Now, the most interesting thing to take away from this drawing is that this little box right here can adopt one of two values. Independently of whatever value this box chooses to adopt, etc. In fact, there are eight independent choices for each of the bits. I am assuming that makes sense to everybody, okay? That means that this, as a grouping - a byte of memory with its eight bits that can independently take on zeros and ones can distinguish between two to the eighth, or two hundred and fifty-six different values. Okay, and that is why the Ascii table is as big as it is, okay? sixty-five through sixty-five plus twenty-five represents the alphabet. I forget where lowercase A starts. But every single character that is ever printed to the screen or printed to a file is backed by some number. I know you know that. When you look in memory to see how the capital A is represented, you would actually see a one right there - I am sorry, I forget where it is actually - a one right there and a one right there. I will draw it out and explain why that is the case. Because capital A is backed by the number sixty-five, we do not put things down in decimal in memory. We put them down in base two. Okay? Because that is what - that is the easiest thing to represent in a bit-oriented system, okay? That make sense to people? Okay. So if I say that the capital A is equal to sixty-five, you have to stop thinking about it as sixty-five. You have to think it about it as some sum of perfect powers of two. So it is not sixty-four - it is not sixty-five rather, it is actually sixty-four plus one. One is two to the zero. A two is two to the first. There is none of that. Four is two to the second. Eight is two to the third. Sixteen is four. Thirty-two is five. Sixty-four is six. This is actually two to the sixth plus two to the zeroth. Make sense? Okay. As far as the representation in a box like this, if you went down and actually examined all the transistors, okay? The eight that are laid side-by-side in a single character, but byte of memory, it would look like this.

And in order to recover the actual decimal equivalent, you really do do - you really do the power series expansion, where you say there is a contribution of two to the sixth because it is in the sixth - counting from zero from the right, the sixth position from the end of the byte. This contributes to the zero, if you can look at it as having contributions of two to the first, and two to the third, and two to the seventh that are weighted by a zero as opposed to a one, okay? That make sense to people? Okay. So that is good enough for characters. Let is graduate to shorts. Some people are very clever when they use shorts. A lot of times they will - if you know that you are going to store a lot of numbers, and they are all going to be small, they will go with an array of shorts, or a vector of shorts, knowing that there really will be some memory savings later on. The short, being two bytes, just means that two neighboring bytes in memory would be laid down. Those are the two bytes at the moment - would be laid down, and the two to the sixteenth different patterns that are available to be placed in that space. It can distinguish between two the sixteenth different values. That make sense to people? Okay. So I will just make this up. I will put lots of zeros over here, except I will put one right there. Did I put too many? Yes. I did. And this is a wide bit. Okay. So as far as the number that that represents - I should emphasize that technically, you can map that pattern to any number you want to, as long as you do it consistently. But you want to make the computer hardware easy to interpret. This place right here means that there is a contribution of two to the zeroth, or one. There is a contribution of two to the first, contribution of two to the second. So there is a two and a four that are being added together. Two to the zeroth, two to the seventh, two to the eighth, two to the ninth. Okay, so there actually is a contribution of two to the ninth, which is five hundred and twelve. So this really is the number that is represented by this thing. It would be five hundred and twelve, five hundred and sixteen, five hundred and eighteen, five hundred and nineteen would have that bit pattern down there, okay? Does that make sense to people? If I have another one - oops, I do not want that there. I have one zero, followed by all ones and all ones, okay? I know that if this had been a one right there, then that would have been a contribution of two to the fifteenth. Does that make sense to people? Okay. Zero followed by all ones in binary is like zero being followed by all nines, in some sense, in decimal. It is one less than some perfect number that has a lot of zeros at the end, okay? Does that make sense? So think about you have a binary odometer on your car, and you want to take a mile off, okay, because you are at, let is say, one followed by fifteen zeros. If you back it up, you expect all of these to be demoted not to nine, but to one. So, as far as a representation is concerned, it is one less the two to the fifteenth. Makes sense? And that number is two to the fifteenth minus one, which I am not going to figure out what it is. Okay? But you get the jest of what is' going on here?

Okay. So that is enough. There is a little bit to be said about this bit right here. If I wanted to represent the numbers zero through two to the sixteen minus one, I could do that. Okay, that is two to the sixteenth different values. I do not want to say that negative numbers are as common as positive numbers, but they are not so uncommon that we do not want to have a contribution of the mapping to include negative numbers. So what usually happens is that this bit, right there, had nothing to do with magnitude. Okay, it is all about sign, whether or not you want a zero there because it is positive, or a one for negative. And that is usually what zero and one mean when they are inside a sign bit. Makes sense? Okay. So if I write down this and I have, let is say, four zeros followed by zero, one, one, one, okay? That is a seven. If I put all zeros there, it happens to be a seven that hogged a little bit more memory, okay? It was a seven character initially, and now it is a seven short. I could argue that this would be the best way to represent negative seven. And you can look at it and you can recover the magnitude based on what is been drawn. And then just say - look all the way to the left - and say that one is basically the equivalent of a minus sign. That would be a fine way to do it if you wanted to go to the effort of actually always looking at the left-most bit to figure out whether it is negative or not. The reason it is not represented this way is because we want addition and subtraction to actually follow very simple rules, okay? Now, let me just be quite obtuse about how you do binary addition. Not because it is difficult, but because it is interesting in framing the argument as to why we adopt a different representation for negative numbers. Let is just deal with a four-bit quantity, okay? And I add a one to it. Okay. Binary addition is like decimal addition with more carries because you just do not have as many digits to absorb magnitude, so one plus one is two, but you write that down as a zero and you carry the one. You do this. And that is how seven plus one becomes eight. Okay. I imagine everybody followed that.

However, I want the computer hardware and its support for addition and subtraction to be as simple and obvious as possible. So what I would like to do is have the number for positive seven, when added to the representation for negative seven, to very gracefully become all zeros. Does that make sense? Well, if I use the same rules, one - I am sorry, zeros followed by zero, zero, one, one, one. This is four of them. This is eight of them. And I want to add that to seven zeros followed by four zeros, zero, one, one, one. Let is put a four in there. Let is put an eight in there. If I followed the same rules - and think about - I mean it is not like - the hardware is what is propagating electrons around and voltages around to emulate addition for us. If we want to follow the same rules, we would say, "Okay. Well, that is naught two. Carry the two. That is three. Carry the one. That is that." Let me just make sure I do not mess this up. Seven plus seven is fourteen, so it would be that right there. Okay. And then you would have eleven zeros followed by a one. If I really just followed the algorithm I did up there blindly, that is how I would arrive at zero. Okay. And that is obviously not right. If I were to argue what representation that is, if this is negative seven, then this has to be negative fourteen. That is not what seven plus negative seven is. Okay. So that means that this right here, as negative number, has to be engineered in such a way that when you add this to this using normal binary ripple add pattern, okay, that you somehow get sixteen zeros right here, okay? It is easier to not worry about how to get all zeros here. It is actually easier to figure out how to get all ones here. So if I put down four, five, six, seven, eight. One, two, three, four, let is mix it up. Let is put the number fifteen down. And I want to figure out what number - or what bit pattern, to put right here to get all ones right here, then you know you would put a bit pattern right there that has a one where there is a zero right here and a zero where there is a one up here, okay? This right here is basically one mile away from turning over the odometer, okay? Does that make sense? Okay. So what I want to do is I want to recognize this as fifteen and wonder whether or not this is really close to negative fifteen.

And the answer is, yes, it is because if I invert - take this right here and I invert all of the bits, if I add one to that number right there, do you understand I get this domino effect of all of these ones becoming zeros? I do get a one at the end, but it does not count because there is no room for it. It overflows the two bytes, okay? So this right here would give me this one that I do not have space to draw because I am out of memory, all the way down. So what I can do is rather than just changing this right here to be a sign bit, I can take the forward number, the positive fifteen, invert all the numbers, and add one to it, okay? Does that make sense? And that is how I get a representation for negative fifteen. This right here, this approach - it is what is called ones' complement - it is not used because it screws up addition. This notation for inventing the representation of the negative is what is called two is complement, okay? It is not like you have to memorize that. I am just saying it. And this is how you have got all zeros. This is positive fifteen. This is negative fifteen. That is zero right there, okay? Does that make sense? The neat thing about two is complement is that if you have a negative number, and you want to figure out what negative of negative fifteen is, you can follow the same rules. Invert all the bits - there, one - and add one to it, okay? And that is how you get positive fifteen back. So this is nice symmetry going on with the system, okay? Make sense? Okay. Now, why am I focusing on this? Because you have to recognize that certainly in the world of characters and shorts, which is all we have discussed so far, that every single pattern corresponds to some real value in our world, okay? Characters, it is one of two hundred and fifty-six values. We can fill in the Ascii table with ampersands and As and periods and colons and things like that, and have some unique integer be interpreted as a character every single time. As long as it is constant and it always maps to the same exact pattern, then it is a value mapping. As far as shorts are concerned, I could have used all sixteen bits to represent magnitude. I am not going to do that because I want there to be just as many negative numbers represented as positive numbers.

So I do, in fact dedicate all of the bits from that line to the right to magnitude, okay, and I use the left one - the left-most bit to basically communicate whether the number is negative or not, okay? That means that since there are two to the sixteenth different patterns available to a two-byte figure, that the short can distinguish between that many values. Rather than having it represent zero through two to the sixteenth minus one, I actually have it represent negative two to the fifteen - I am sorry, negative two to the fourteen - I am sorry, negative two to the fifteenth through two to the fifteenth minus one. Does that make sense? And everything is center around zero. So I have just as many representations for negative numbers as I have for positive numbers. Okay? Makes sense? Okay. So let is start doing some really simple code, not because it is code you would normally write. Sometimes you do, not very often. But just to understand what happens when you do something like this. I have a CAR variable, CH, and I set it equal to capital A. And then I have an int variable called - actually, let me make it a short - S, and I set it equal to CH. You do not need a cast for that. What you are really doing is you are just setting S equal to whatever number is backing CH. There is a question right there?

Student:[Inaudible]

Instructor (Jerry Cain):All right. It should not have been. Oh, I just - I am sorry, I inverted the bit pattern, and then I said you would add one to this, and I just did not change the bit in the drawing. Where would you go? I just saw - okay. So I did not add one to this yet. But in the conversation at the time I thought it was clear. Okay. Does this make sense to people? Okay. There is - certainly it is gonna compile and it is going to execute. And based on the other seven boards I have drawn in, you should have some idea as to what is gonna happen in response to this line. Print out is the equivalent of a cout statement, but it is in pure C. And if I want to print out a short - actually, let me just cout. Less than, less than S is less than, less than PNDL. In response to that, I expect it to print out the number sixty-five. So to the console I would expect that to be printed. Why is that the case? Because the declaration of CH does not put a capital A there, it puts the integer value that backs it there, which I will draw as decimal. You know that it is really ones and zeros. And so when time comes for you to assign to S, what happens in order to achieve the effect of the assignment, it will copy this bit pattern. And this is what it really does electronically. It just replicates whatever bit pattern is right here onto that space right there. It smears these bits onto this little byte like it is peanut butter. And puts a sixty-five down there. And all the extra space is just padded, in this case, with zeros. So that is how sixty-five goes from a one-byte representation to a two-byte representation. Does that make sense? I simplified this a little bit. When I put a sixty-five down here and a smear of sixty-five in there, I happen to know that the left-most bit is a zero there. It is a positive number so that should not surprise you, okay? Does that make sense to people? What happens if I do the opposite direction? I do this int - I am sorry, we are not at ints yet. Short - completely new program - S is equal to, I will say sixty-seven, and I do this. It compiles. There is no casts needed. As far as how the sixty-seven is laid down, it is zero, one, zero, zero, zero, zero, one, one. It is two more than sixty-five, obviously. It has an extra byte of all zeros. And this is S.

So when CH gets laid down in memory, and it is assigned to S, two bytes of information, and sixteen bits cannot somehow be wedged economically into an eight-bit pattern. So what C and C plus  plus , and many program languages for that matter, do is they simply punt on the stuff they do not have room for. And they assume that if you are assigning a large number to a smaller one, and the smaller one can only accommodate a certain range of values in the first place, that your interested in the minutia of the smaller bits. Does that make sense to people? So what happens is it replicates this right here, and it punts on this. And this is how, when you do this right here, okay, you go ahead and you print out a C. Make sense to everybody? Okay. Now, I have kind of evaded the whole negative number things, but negative values do not work too well with characters because unsigned CARs - most characters are unsigned. So you actually do get all positive values with the representations. You know enough about shorts to know that the two-byte figures - I have already told you that longs and ints, at least in our world, are four bytes. They are just a four-byte equivalent of a short. So let me deal with this example. I go ahead and I do a short, S is equal to, I will just say - let me write it this way. No, I will just write it as two to the tenth plus two to the third plus two to the zero. That is, of course, not real C. But I am just writing it because I want to be clear about what the bit pattern for that number is. So just think about whatever number that adds up to as being stored in S. Okay. This is two to the eighth, two to the ninth. One, zero, zero, preceded by all zeros. Lots of zeros. One, zero, zero, one. If I take an int, i, and I set it equal to S, the same argument that I made in the CAR to short assignment can be taken here. And this is how - and this is somehow less surprising because both of them represent integers.

This is all zeros. All zeros. Lots of zeros followed by one, zero, zero, zero, zero, zero, zero, one, zero, zero. And that is why. You just have a lot more space to represent the same small number, okay? Trick question. If I set int i equal to - I have thirty-two bits available to me to represent pretty big numbers, so I am gonna do this. Two to the twenty-third plus two to the twenty-first plus two to the fifteenth plus, let is say, seven. Okay? And I am being quite deliberate in my power of two representation of these numbers because seven always means that at the bottom, okay? Two to the fifteenth means there is a one right there. Two to the - actually, let me change this to two to the fourteen. Make this a zero, one. Two to the twenty-first - although this is two to the twenty-fourth. Two to the twenty-third, followed by zeros. All zeros right there. So that is more or less what the bit pattern for that, as a four-byte integer would look like. I go ahead and I set short S equal to i. You could argue that wow, that numbers so big it is not gonna fit in the short, okay? And so you might argue that well maybe we should try and come as close as possible and make S the biggest number it can be so it can try really hard to look like this number. And that is not going to happen. It is gonna do the simplest thing. Remember this is implemented electronically, and every single example over there has more or less been realized by just doing a bit pattern copy, okay? If you are writing this way, you probably know that you are going and taking a four-byte quantity and using it to initialize a two-byte quantity. So lay that down, this is S. And all it does is say, "You know what, I have no patience for you right there. You are out. I am just gonna copy this down." Okay? And so I do this followed by lots of zeros, followed by lots more zeros, followed by one, one, one. And I print out S. I am gonna get the number that is two to the fourteenth plus seven. Does that make sense to people?

Okay. So let me go back and do one more example before I move on to floating-point. Oh, yeah?

Student:Initially you had three to the fifteenth?

Instructor (Jerry Cain):Right. I would say it is - it is actually confusing as to what happens. It certainly is. I actually do not know what happens when what is a magnitude bit actually becomes a sign bit. I have to say I certainly should know what happens. I just do not, which why I gracefully said, "Oh, I have an idea. Let me just change this to two to the fourteenth." I will actually run this remnant after lecture and I will just mail the class this as part of this email that everyone is getting today, okay? Yep?

Student:[Inaudible] the other way around [inaudible] a sign short [inaudible]?

Instructor (Jerry Cain):Well, it will always preserve sign, and I am gonna - that is the very example I am gonna do right now, okay? Suppose I did this. Short S is equal to negative one. Totally reasonable. Do any of you have any idea what the bit pattern for that would look like? And you can only answer if you did not know the answer prior to eleven:zerozero a.m. today. Okay. I want to be able to add one to negative one and get all zeros, okay? Does that make sense? So the representation for this is actually all ones. In fact, anytime you see all ones in a multi-byte figure, it means it is trying to represent negative one. Why? Because when I add positive one to that, it causes this domino effect and makes all those ones zeros. Does that make sense? So to answer your question, int i equal to S, logically I am supposed to get int to be this very spacious representation of negative one. It actually does use the bit pattern copy approach. It copies these. I have just copied all the magnitude, okay? And by what I put down there, it is either one or - I am sorry. It is either a very large number or it is negative one. We are told that it is negative one right there, okay? What happens is that when you assign this to that right there, it does not just place zeros right there because then all of the sudden it would be destroying the sign bit. It would be putting the zero in the sign bit right there. Make sense? So what it really does, and it actually did this over here, but it was just more obvious, is it takes whatever this is in the original figure and replicates that all the way through. If these would have otherwise been all zeros, and I want to be able to let this one continue a domino effect when you add a positive number to a negative number, you technically do what is called "sign extend" the figure with all of these extra ones. So now you have something that has twice as many dominos that fall over when you add positive one to it, okay? Does that make sense?

Okay. So there you have that. As far as character shorts, ints, and longs, they are all really very similar in that they some binary representation in the back representing them. They happen to map to real numbers, for ints, longs, and shorts. They happen to pixelate on the screen as letters of the alphabet, even though they are really numbers, very small numbers in memory, okay? But the overarching point, and I do not want you to - I actually do not want you to remember - memorize too much of this. Like, if you know what - if you know that seven is one, one, one, and you know that all ones is negative one, that is fine. I just want you to understand the concept with integers I have four bytes. I have thirty-two bits. That means I have two to the thirty-second different patterns available to me to map to whatever subset of a full integer range I want. The easiest thing to do is to just go from two to the negative thirty-first through two to the positive thirty-first minus one, okay? There is zero in the middle. That is why it breaks it symmetrically a little bit. When I go and start concerning myself with floats - I - you are probably more used to doubles, but this is just a smaller version of doubles. I have four bytes available to me to represent floating-point numbers, integers with decimal parts following it, in any way I want to. This is not the way it really works, but let me just invent an idea here. Pretend that this is how it works. We are not drawing any boxes yet. I could do, let is say I have a sign bit. I will represent that up here as a plus or minus. And if I have thirty-two bits, you would, by default, thinking about bits and contribution of two to the thirtieth, two to the twenty-nine, all the way down through some contribution of two to the zero. And I am just describing all the things that can adopt zeros or ones to represent some number, okay? But I want floats to be able to have fractional parts.

So I will be moving in the fractional direction, and say, "You know what? Why do not I sacrifice two to the thirtieth, and let one bit actually be a contribution of two to the negative first?" I am just making this up. Well, I am not making it up. This is the way I have done it the last seven times I taught this. But I am moving toward what will really be the representation for floating-point numbers. If I happen to have thirty-two bits right here. And I lay down this right here. That is not the number seven - I am sorry, that is not the number fifteen anymore. Now, it is number seven point five. Does that make sense? Okay, well floats are not very useful if now all you have are integers and half-integers. So what I am gonna do is I am gonna stop drawing these things above it because I have to keep erasing them. Let is just assume that rather than the last bit being a contribution of two to the negative first, let me let that be a contribution of negative two to the negative first, and that let that be a contribution of two to the negative two. Now I can go down to quarter fractions. Does that make sense? Well, what I could do is I could make this right here a contribution of two to the zero, two to the negative one, two to the negative two, three four, five, six, seven, eight, two to the negative nine. And if I wanted to represent Pi - I am not going to draw it on the board because I am not really sure what it is, although I know that this part would be one, one - then I would use the remaining nine bits that are available to me, okay, to do as good a job using contributions of two to the negative first, and two to the negative third, and two the negative seventh to come as close as possible to point one four one five whatever it is, okay? Does that make sense to - I am assuming? It is an interesting point to remember that because you are using a finite amount of memory, you are not going to do a perfect job representing all numbers in the infinite, and infinitely dense, real number domain, okay? But you just assume that there is enough bits dedicated to fractional parts that you can come close enough without it not really impacting what you are trying to do, okay? You only print it out to four decimal places, or something that just looks like it is perfect, okay? Does that make sense? It turns out if I do it that way, then addition works fine. So I add two point five contributions and it ripples to give me a one and I carry a one. It just words exactly the same way. Does that make sense? Okay. It turns out that this is not the way it is represented, but it is a technically a reasonable way to do it. And when they came up with the standard for representing floating-point numbers, they could have gone this way. They just elected not to.

So what I am gonna do now is I am gonna show you what it really does look like. It is a very weird thing. But remember that they can interpret a thirty-two-bit pattern any way they want to, as long as the protocol is clear, and it is done exactly the same way every single time. So for the twentieth time today, I am gonna draw a four byte figure. I am gonna leave it open as four byte rectangle because I am not gonna subdivide it into bytes perfectly. I am going to make this a sign bit because I do want to represent - I want negative numbers and positive numbers that are floating-point to have an equal shot at being represented, okay? That is one of the thirty-two bits. Does that make sense? The next eight bits are actually taken to be a magnitude only - I say it that way. I should just call it an unsigned integer - from here to there, okay? And the remaining twenty-three bits talk about contributions of two to the negative one, and two to the negative two, and two to the negative three. Okay, this right here, I am gonna abbreviate as EXP. And this right here, I am just gonna abbreviate as dot XXX XX, okay? The - what - this figure and how it is subdivided is trying to represent this as a number. Negative one to - I will abbreviate this as S - to S right there. One point XXX XX times two to the one twenty-eight - I am sorry, hold on a second. EXP minus one twenty-seven, okay? It is a little weird to kind of figure out how the top box matches to the bottom one. What this means is that these twenty-three bits somehow take a shot at representing point zero, perfectly as it turns out, to something that is as close to point nine, nine bar as you could possibly get with twenty-three bits of information. When these are all ones, it is not negative one. It is basically one minus two to the twenty-third. Does that make sense to every? Okay. That is added to one to become the factor that multiplies some perfect power of two. Okay? This right here ranges between two to the eighth - I am sorry, two hundred and fifty-five and zero. Does that make sense?

When it is two hundred and fifty-five and it is all ones, it means the exponent is very, very large. Does that make sense? When it is all zeros, it means the exponent is really small. So the exponent, the way I have drawn this here, can range from one hundred and twenty-eight all the way down to negative one hundred and twenty-seven. Makes sense? That means this right here can actually scale the number that is being represented to be huge, in the two to the one twenty-eight domain, or very small, two to the negative one twenty-seventh, okay? The number of added to the world down to the size of an atom, okay? You may think this is a weird thing to multiply it by, but because this power of two-thing right there really means the number is being represented in the power of two domain. You may question whether or not any number I can think of can be represented by this thing right here. And then once you come up with a representation, you just dissect it and figure out how to lay down a bit pattern in thirty-two byte - thirty-two-bit figure. Let me just put the number seven point zero right there. Well, how do I know that that can be represented right here? Seven point zero is not seven point zero. It is seven point zero times two to the zeroth, okay? There is not way to get and layer that seven point zero over this one point XXX and figure out how - what XXX should be. XXX is bound between zero and point nine bar. But I can really write it this way. Three point five times two to the first, rather one point seven five times two to the second. So as long as I can do a plus or minus on the exponent, I can divide and multiply this by two to squash this into the one to one point nine range. And just make sure that - I have to give up if this becomes larger than one hundred and twenty-eight or less than negative one hundred and twenty-seven. But you are dealing with, then, absurdly large numbers, or absurdly small numbers. But doubles love the absurdity because they have space for that accurate of a fraction, okay? Does that make sense to people? Okay, so this right here happens to be the way that floating-point numbers are actually represented in memory. If you had the means, and you will in a few weeks, to go down and look at the bit patterns for a float, you would be able to pull the bit patterns out, actually write them down, do the conversion right here, and figure out what it would print at. It would be a little tedious, but you certainly could do it. And you would understand what the protocol for coming from representation to floating-point number would be, okay? Let me hit the last ten minutes and talk about what happens when you assign an integer to a float, or a float to an integer, okay? I am gonna get a little crazy on you on the code, all right. But you will be able to take it.

I have this int i is equal to thirty-five - actually, let me chose a smaller number. Let me do just five is fine. And then I do this. Float F is equal to i. Now you know that this as a thirty-two-bit pattern had lots of zeros, followed by zero, one, zero, one at the end, four plus one, okay? Makes sense? When I do this, if I print out F, do not let all this talk about bits and representation confuse the matter. When you print out F there, it is going to print the number five, okay? The interesting thing here is that the representation of five as a decimal number is very, very different than the representation of five using this protocol right here. So every time - not that you should not do it - but every time you assign an int to a float, or a float to an int, it actually has to evaluate what number the original bit pattern corresponds to. And then it has to invent a new bit pattern that can lay down in a float variable. Does that make sense? This five is not - the five is not five so much as it is one point two five times two to the second. Okay, as far as this is concerned right here. So that five, when it is really interpreted to be a five point zero, it is really taken to be a one point two five - is that right? Yeah. - Times two to the second. So we have to choose EXP to be one hundred and twenty-nine and we have to choose XXX to be point two five. That means when you lay down a bit pattern for five point zero, you expect a one to be right there. And you expect one - one, zero, zero, zero, zero, zero, zero, one to be laid down right there, one hundred and twenty-eight plus one. Does that make sense to people? You gotta nod your head, or else I do not know. Okay. This is very different - and this is where things start to get wacky - and this is what one oh seven is all about. If I do this right here, int i is equal to thirty-seven. And then I do this, float F is equal to asterisk - you are all ready scared. Float, star, ampersand of i. I am gonna be very technical in the way I describe this, but I want you to get it. The example above the double line, it evaluates i, discovers that it represents five, so it knows how to initialize F. Does that make sense? This right here is not an operation. It does not evaluate i at all. All it does is it evaluates the location of i. Does that make sense? So when the thirty-seven, with it is ones and zeros represented right there, this is where i is in memory. The ampersand of i represents that arrow right there, okay? Since i is of type int, ampersand of i is of type int, star, raw exposed address of a variable. That is four bytes that happens to be storing something we understand to be an int. And then we seduce it, momentarily, into thinking that it is a float star, okay?

Now, this does not cause bits to move around, saying, "Oh, I have to pretend I am something else." That would be i reacting to an operation against the address of i, okay? All the furniture in the house stays exactly the same, okay? All the ones and zeros assume their original position. They do not assume, they stay in their original position. It does not tell i to move at all. But the type system of this line says, "Oh, you know what? Oh, look. I am pointing to a float star. Is not that interesting? Now, I am gonna be reference it." And whatever bit pattern happened to be there corresponds to some float. We have no idea what it is, except I do know that it is not going to be thirty-seven point zero, okay. Does that make sense? In fact it is small enough that all the bits for the number thirty-seven are gonna be down here, right, leaving all of these zeros to the left of it, okay? So if I say stop and look at this four byte figure through a new set of glasses, this is going to be all zeros, which means that the overall number is gonna be weighed by two to the negative one twenty-seven. Makes sense? There is gonna be some contribution of one point XXX, but this is nothing compared to the weight of a two to the negative one twenty-seven. So as a result of this right here, and this assignment, if I print out F after this, it is just gonna be some ridiculously small number because the bits for thirty-seven happen to occupy positions in the floating-point format that contribute to the negative twenty-third, and to the negative twentieth, and things like that, okay? Does that make sense to people? Okay. So this is representative of the type of things that we are gonna be doing for the next week and a half. A lot of the examples up front are going to seem contrived and meaningless. I do not want to say that they are meaningless. They are certainly contrived because I just want you to get an understanding of how memory is manipulated at the processor level.

Ultimately, come next Wednesday, we are gonna be able to write real code that leverages off of this understanding of how bits are laid down, and how ints versus floats versus doubles are all represented, okay? I have two minutes. I want to try one more example. I just want to introduce you to yet one more complexity of the C and C plus  plus  type system, and all this cast business. Let me do this. Let me do float F is equal to seven point zero. And let me do this short S is equal to asterisk, short star, ampersand of F. Looks very similar to this, except there is the one interesting part that is being introduced to this problem, is that the figures are different sizes, okay? Here I laid down F. It stores the number seven point zero in there. And that is the bit pattern for it, okay? The second line says, "I do not care what F is. I trust that it is normally interpreted as a float, and that is why I know that this arrow is of type float, star." Oh, let is pretend - no, it is not any more. You are actually pointing - that arrow we just evaluated? It was not pointing to a float. We were wrong. It is actually pointing to a two byte short. So all of the sudden, it only sees this far, okay? It is got twenty-forty vision, and this right here, this arrow, gets dereferenced. And as far as the initialization of S is concerned, it assumes that this is a short. It assumes that this is a short so it can achieve the effect of the assignment by just replicating this bit pattern right there, okay? And so it gets that. Okay, and whatever bit pattern that happens to correspond to in the short integer domain, is what it is. So when we print it out, it is going to print something. Seven point zero means that there is probably gonna be some non-zero bits right here. So it is actually going to be a fairly - it is gonna have ones in the upper half of the representation. So S is gonna be non-zero. I am pretty sure of that, okay? Does that make sense to people?

Okay. That is a good place to leave. Come Monday, we will start talking about - we will talk a little bit about doubles, not much. Talk about strucks, pointers, all of that stuff, and eventually start to write real code. Okay.

[End of Audio]

Duration: fifty-one minutes



