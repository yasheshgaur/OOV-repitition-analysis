Programming Paradigm-Lectureeleven

Instructor (Jerry Cain):Hey, everyone. Welcome. I actually have one handout for you today, and Ryan just walked in with it. So he is going to be passing it around to the people who are in the room. Remember, we have a special discussion section today, at - I am forgetting what time it is. What did I say? one:fifteen p.m.? I would check.-whatever I said on Wednesday. What did I say? two:fifteenpm, okay. I do not know why I am forgetting: two:fifteenpm to three:zerofivepm, in scaling one hundred and ninety-one. We are having a special discussion section, just this one week because I want some example problems to be in - to sit in front of you, and for you to think about them, more than two days before the next assignment deadline. Which is why I am having it today.

It is going to be videotaped. I am gonna call SCPD after the lecture today, and try and make sure that they post it by five:zerozero p.m. today, so it is around for the weekend, online, so you can watch it. But I have already, I think, pretty well advertised it, Assignment four; I think to be kind of the biggest surprise in terms of workload and difficulty for most students. So that is why I am kind of advertising it now, to be something you want to start on, sooner than later. Because if you start next Thursday, it is very likely, you will not finish on time. So just try and get - take a stab at it a little bit ahead of time, this time.

When I left you last time, I had shown you two examples of how function call and return works, in general, but specifically in our assembly language. So what I want to do is, I want to do one specific example, actually much, even simpler than the last example I did. Because I want to make a transition from C code generation to C  plus   plus  code generation, and show you just how similar the two languages ultimately end up looking like, when they compile to assembly code.

So let is deal with this scenario: a void function. I just want to say foo, and I will concern myself with the allocation of two local variables. I will set x equal to eleven; I will set y equal to seventeen. And then, I am going to call this swap function. This time, I am interested in writing swap to show you what the assembly code looks like. And I think you will be surprised to see how the pointer version of swap and the reference version of swap look exactly the same. But the way I am writing it, right now, this is pure C code. Actually, you can call it C  plus   plus  code, for that matter. And then, that is all I want to do.

I just want you to understand how code for this would be generated. I do not have any parameters, whatsoever, so I would expect the stack pointer, right there, to have the safe p c associated with whatever function happens to be calling foo, right here. There is a call foo instruction in someone else is assembly stream, and that safe p c is the address of the instruction that comes directly after that. That is the trail of popcorn I was talking about, on Wednesday. The first thing that will happen is that this thing will actually make space for its two locals. I actually like getting in the habit of kind of taking care of my deallocation call right away. That make sense to people? Okay? Well, as soon as I write that, I just want to remember just so I just do not forget to put it on the page. I like to put the balancing s p change at the bottom of the stream. Now, I will concern myself with this, right here. This brings this down, to introduce those eight bytes. X is above y, so this instruction right there, translates to m of s p plus four is equal to eleven; then m of s p is equal to seventeen, and then virtually all of the rest is associated with the work that is necessary to set up and react to - set up a function call, and react to its return. Okay? So what I want to do here is I want to evaluate ampersand of x, and ampersand of y. The fact that they are an eleven here - oops - an eleven there and a seventeen, is really immaterial to the evaluation of these two things, right here. This, given that setup right there, is synonymous with a p c plus four; this is synonymous with p c. Okay? I want to put those values in registers: R one is equal to s p - I am sorry, that is right - s p y two is equal to s p plus four. This is ampersand of y; this is ampersand of x. I want to further decrement the stack pointer by minus eight. The fact that this is minus eight is just a coincidence with that being minus eight. There happen to be two four-byte parameters being passed here; there were two four-byte parameters - two four-byte locals, local to foo. Once I have done that, I have decremented this by four more bytes. That marks the bottom of the foo activation record. I am now building a partial activation record for the swap function. I want to lay this as a figure, right there. This, as a figure, right there. This first parameter, the zero parameter, actually goes at the bottom. So I want to do this: m of s p, which just changed, is equal to r two; m of s p plus four is equal to r one. Okay? That, basically, gets this right here, to point to that, and this to point to that. So when we go ahead, and call this swap function, we are just inferring its prototype to take two int stars, it just sees this. Technically, it has the addresses, the locations of the two ints it is going to be dealing with, but it does not, technically, know that they are right above it on the stack frame. It actually just has the addresses on their little houses that just happen to be just down the block. Okay?

This, right here, all it has to do is basically clean up the parameters. When the call swap function happens, p c is pointing right there. It can, by protocol, assume that that is where the safe p c is left - I am sorry, the stack pointer is left, when it jumps back to this instruction because the return at the end of the swap is responsible for bringing it all the way back up here, just by protocol. Does that make sense? Okay.

So all we need to do: fill in the space. This balances that; that balances that. You could coalesce these to one statement, if you wanted to. I just do not see a compelling reason to. And then, since there is nothing being done with the new values of x and y, I can just return. Okay? Does that make sense to people? As far as the code for swap is concerned, this is void swap. I will write it to be int star specific; a p int star b p int temp is equal to asterisk a p. There is actually a little bit of work here, at the assembly code level. I know you have seen this implementation, probably forty times, in the last two quarters, but there is some value in actually seeing it, one final time, and for me to generate assembly code for it.

It starts executing with the assumption that s p is pointing to a safe p c. In this particular example, it happens to be that address, right there, that is the safe p c. This is internally referred to as a p, b p. It is not like the words a p and b p are written on the hardware, but there is just - the code is generated, in such a way, that a p is always synonymous, at the moment, with s p plus four; and b p is synonymous with s p plus eight. Okay? The moment the stack pointer points right there, I have to make space for my one local variable. That happens because I do this. I will make it clear that this is associated with the label swap that we actually call or jump to. That brings this down here. This is locally referred to as temp in the code; this is the space that corresponds to temp in the activation record. The offsets of a p and b p actually shift, a little bit. Now, this is an address, s p plus eight, s p plus twelve. I have to rely on these things pointing to real data. I do not need to know where that data is to write the correct assembly code. I need to evaluate a p and then, what a p points to. So as part of initializing that, right there, I have to load into a register, m of s p plus eight. Do you understand that it lifts this bit pattern, right there, and places it in a register, so I can basically do a cascade of dereferences. Does that make sense to people? Okay? Now I have a p in the register, I can do this and now I have the very integer that is addressed by this a p thing, okay, sitting inside r two. You may ask whether or not you can do something like this. Conceptually, of course you can do that, except you are not going to find an architecture that supports double cascade in a single assembly code instruction. Okay? So that is why they are broken up over several lines.

So let is assume that this points to that, right there, that the integer that has to be loaded into temp. That is only going to happen because I do this. Oops. And that ends this line, right here. Does that make sense to people? Yeah, go ahead.

Student:When you say rtwo equals m, r of r one -

Instructor (Jerry Cain):Yep.

Student:Why does it not just copy the address in, say, a p and actually [inaudible]

Instructor (Jerry Cain):Well, the memory of - you basically go inside an array of bytes that is based addressed, right there. Okay? So you think about the entire array of - entire array of bytes that is in RAM as being indexed from position zero. And so when you put that number inside, it actually goes to that address. We know that s p plus eight, this right here, we know that the four byte bit pattern that resides there is actually the raw address of some integer. The assembly code does not know that, but we do. So we are asking it to shovel around a four-byte figure and put it into this temp variable. Right? This loads that address. This address right here, let is say it is address four,zerozerozero. I just loaded a four,zerozerozero into r one. Maybe it is the case that the seventeen is in address four,zerozerozero. Okay, that would make sense. So by effectively doing m of r one, in this particular case, I am doing m of four,zerozerozero because that is what r one evaluates to. Okay? And by default, we always do it with four-byte transfers. Okay? So this would get a seventeen to play the role of happy face, and would put a seventeen right there. Does that make sense? Okay. So now, what has to happen is something similar. I have to do this right here. But it is actually a little different than this line right here because I have to find the L value by actually following a pointer. The L value, being temp, is directly on the stack frame, in this case. Right? The space where the new value is being written is actually one hop off of the stack frame. Okay? Let me evaluate asterisk b p first because it is very similar. I will do r one is equal to m of s p plus twelve. That loads just the value of b p because that is what is stored as a variable on the stack frame. Okay? In r two, I will do m of r one, but r one has a different value this time. Maybe it is the flat emoticon, okay, and that gets loaded into the r two register. That is what actually has to be written over this smiley face, right there. Make sense? So in order for that to happen, I have to load this again: r three is equal to m of s p plus eight. And I do not want to load m of r three because I do not care about the old value. I want to actually want to set m of r three equal to r two. Okay? Does that sit well with everybody? Just making sure I did that right. Yeah, a p right there. Okay? Making sense? The last line is actually very similar to the first one. I know that temp is sitting right at the base of the entire activation record. Now, what I have to do is I have to load the address associated with b p into r two. That is stored at m of s p plus twelve. And then I have to do m of r two - I am sorry, yeah - m of r two is equal to r one. That realizes this, right here. So in those three blocks, I have achieved the algorithm that is the rotation of these three-of these two-byte patterns, actually, through a third. Right before I clean this up here, I have to do an s p is equal to s p plus four. Internally, I have to bring the stack pointer up to the place where it was before I executed any code for this function. Okay? That means that s p is now pointing to the safe p c. Which is perfect because in response to this return instruction, our return actually knows, just procedurally, to go ahead and pull that value out, populate it with the - place it into the real p c register and simultaneously, or just after that, bring this back up to there. Okay? That is exactly where the s p pointer was pointing before that call statement. Does that make sense? Okay.

So I went through that exhaustively because pointers are still mysterious for some people, and understandably, because they are difficult. So if you start to understand them, at the hardware level, you have some idea as to what the pointers are trying to achieve. They really are raw locations of figures being moved around, or at least, manipulated. Okay? What I want to do now is, I want to show you what the activation record and the function call and return mechanisms would be for the C  plus   plus  version of swap. This is very close. I will write it again and leave it as an open question, for about two minutes, as to what the activation record must look like. I will just do a int ampersand b. So just pretend we are dealing with pure C, except that we have integrated the reference feature from C  plus   plus . Okay? Int temp is equal to - what did I see over there?-a, and a is equal to b, and then b is equal to temp. Algorithmically, it looks similar, and it even sort of has the same side effect. But you may question how things are actually working behind the scenes, in order to swap things by reference, as by opposed address. Let me draw the activation record for you. This is the thing that is referred to as a; this is the thing that is referred to as b. This is always below that. That is just the rule for parameters to a function or a method call. There is a safe p c, right here, pointing to the instruction that comes right after the call to the swap function. And then, ultimately, the very first instruction does an s p is equal to s p minus four. So that, this is the entire activation record that is in place before swap actually does anything in terms of byte moving around. Okay? This a and this b, just because we refer to them as if they are direct integers does not mean that, behind the scenes, they have to actually be real integers. The way pointer - I am sorry - the way references work is that they are basically just automatically dereferenced pointers. Okay? So without writing assembly code for this, when I do this, and I do this, just because I am passing in x and y - that is the way you are familiar with the swap function from one hundred and sixb and one hundred and sixx - just because you are not putting the ampersands in front of those xs and ys, does not mean that compiler is blocked from passing their addresses.

This, right here, has to be an L value; this has to be an L value, as well. It means it actually has to name a space in memory, okay, that can be involved in an update or an exchange by reference. When this, right here, is compiled to csone hundred and seven assembly language, it actually does exactly the same thing that that does, right there. C  plus   plus  would say, "Oh, this is x and y, but I am not supposed to evaluate x and y because I can tell, from the prototype, that they are being evaluated - they are being passed by reference." So the way it does it is, on your behalf, just secretly says, "Okay, they need - they really need this x and this y to be updated in response to the swap call." That is only gonna happen if this, as a function, knows where x and y are. Okay? So the illusion is that a and b, as stand-alone integers, are second names for what was originally referred to as x and y. Behind the scenes, what happens is that this lays down a pointer and this lays down a pointer. You do not have to use the word pointer to understand references; you can just say it is magic and somehow, it actually does update the original values. It lays down the address of these things. The assembly code that is generated for this function, right here, understands even though you do not necessarily know this. It understands that it is passing around pointers wherever references are expected. And so it automatically does the dereferencing of the raw pointers that implement those references, for you. The assembly code for this function is exactly the same as this, like, down to the instruction, down to the offsets; everything is exactly the same. Okay? Do you understand how that is possible? Just because you do not put ampersands in there, does not leave the compiler clueless because it knows, from the prototype, that it is expecting references. It is just this second flavor of actually passing things around by address. You are just not required to deal with the ampersands and the asterisks. Okay?

It knows because of the way you declared these, that every time you refer to a and b in the code, that you are really referring to whatever is accessible from the address that is stored inside the space for a. Okay? Does that sit well with everybody? Okay, that is good. So people freaked out a little bit on Assignment one, I think - or Assignment two - when they saw local variables declared as references. Like, you are used to the whole parameter being a reference, as if this data type and that data type, you are only allowed to put them in parameter lists. That is just not true. If you want to do this, if you do this right here, then that is just traditional allocation of a second variable that happens to be initialized to the x variable - I am sorry - to whatever x evaluates to. Okay? And that is just normal. If you want to do this, you can. Okay? And this is not a very compelling reason because ints are small, and there is no algorithm attached to this code. So you are not necessarily clear why it would do that. The was this is set up, is that x really is set aside as an integer, with a seventeen; y is really set aside with it is own copy of the seventeen. But z is declared - you drew them in one hundred and sixb and one hundred and sixx, this way. And the picture is totally relevant to the actual compilation measures because it really does associate the address of y inside the space that is set aside for z. Okay? Does that make sense? If I were to do this, you would totally draw that without the shaded box. Right? This and this, from an assembly code standpoint, are precisely the same. At the C and C  plus   plus  language level, you are required to put the explicit asterisk in here; you are not there. Okay?

You may say, "Well, why would I ever use actual pointers, if references just become pointers?" Well, references are convenient, in the sense that they give the illusion of second names for original figures that are declared elsewhere. The thing is, with references, you cannot rebind the references to new L values. Do you understand what I mean when I say that? It is a technical way of saying you cannot reassociate z with x, as opposed to y. Once it is bound as a reference to another space, that is in place forever. So you do not have the flexibility to change what the arrow - where the arrow points to. You do have that ability with raw pointers. So you could not very easily build a link list, if you just had references. Does that make sense to people? Okay. So that is why the pointer still has utility, even in C  plus   plus . Okay? You saw a method where - I think it was, like, get last player, or something like that. There was some method, in one of the classes for Assignments one and two, that returned a reference. If you were, like, "I have never seen that before; what does that mean?" All it is doing is it is returning a pointer behind the scenes, okay, and you do not have to deal with it that way. You can just actually assume that it is returning a real string, as opposed to a string star, or an int as opposed to an int star, and just deal with it like that. But behind the scenes, it is really referring to an int or a string that resides elsewhere. Does that make sense to people? Yes, no? Okay. So even though in C - when you - C  plus   plus , you start dealing with references, it is not like the compilation efforts that are in place. And the assembly code that is generated is fundamentally different in the way it supports function call and return, and just code execution. Okay? It just has a different language semantic at the C  plus   plus  level that happens to be realized, similarly, at the assembly code level. Okay?

References are the one addition to C  plus   plus , I am sorry, there is a few -but there are - a lot of people, when they program in C  plus   plus , they actually program in C, where they just happen to use objects and references. They do not use inheritance; they do not necessarily use templates all that often, although most of the time, they do. But that is not an object-oriented issue. They do not use inheritance; they do not use a lot of the clever little C  plus   plus isms that happen to be in there. They really just code in C, with references and objects. And they just think of references as more convenient pointers, less confusing. And they think of objects as structs that happen to have methods defined inside. Does that mean there is a reasonable analogy I am throwing by, I am assuming? Okay? Well, when you program as an LL purist, you are not supposed to think of objects as structs, you are supposed to think of them as these alive entities, that actually are self-maintaining and you communicate with them through the series of instructions that you know they they will respond to because you read the dot h file. Okay? Turns out that structs and classes - just looking at this from an "under the hood" perspective - structs and classes are laid down in memory virtually the same way. Not even virtually, exactly the same way. Okay? In C  plus   plus , structs can have methods. The structs - I am not misusing a word there - structs can have constructors, destructors, and methods, as can classes. Classes are not required to have any methods. The only difference between structs and classes, in C  plus   plus , is that the default access modifier for classes is private, and the default access modifier for structs is public. Does that make sense to people? Okay? So the compiler actually views them as more or less the same thing. It is just there is a little bit of basically a switch statement at the beginning, where it says, "Was it declared as a struct or a class?" And then, it says, "Okay, it is either private or public, by default." Okay?

When you do something like this: class, I am gonna say - I will just do binky, and I will worry about the public section in a second. Let is not worry about constructors or destructors. They are interesting, but they are just complicated, so I want to blow them off for a minute. And then, privately, let is say that I have an int called winky, a char star called blinky, and let is say I have a wedged character array of size eight, called slinky. And let is just get all these semicolons to look like semicolons. And that is it. And those are the only data fields I push inside. Every single time you declare one of these binky records, or binky objects, you do this. It should not be that alarming that you really get a blob of memory that packs all the memory needed for these three fields into one rectangle. And it uses exactly the same layout rules because of all the fields, winky is declared before whatever I called it, blinky. And then, on top of that, is an array of eight characters called slinky, that this entire thing is the b type. It is laid out that way because if you look at this, and think of it as a struct, the layout rules are exactly the same. Winky is stacked at offset zero; this is stacked on top of that, and this resides on top. This is an exposed pointer, which is why there four bytes for that rectangle. This is an array that is wedged inside the struct/class, which is why it looks like that for the upper fifty percent of it. When you do something like this - forget about constructors, let is just invent a method, right here. Let is just assume that I have this method, int and some other thing, donkey where I pass in - let is say a [inaudible] x and an int y. Okay? And let me actually declare another method, char star - I am running out of consonants - minky, and all I want to do is I want to pass in, I will say, an int star called z. And I will inline the implementation of this thing to do this: int y - I do not want to do that - int w is equal to asterisk z. And then, I want to return slinky plus whatever I get by calling this donkey method.

I am not going to implement all the code for this, but I will do this: Winky, winky, and that is gonna be good enough. It is a very short method. You do not normally inline it in the dot h; I am just putting all the code in one board. Okay? Just look at this from an implementation standpoint, and let me ask something I know you know the answer to. Z right there, is explicitly passed in as a parameter; w is some local variable, okay, that is clearly gonna be part of the activation record for this minky thing. Why does it have access to winky right there, or slinky right there? Because you know that it has the address of the object that is being operated on. Does that make sense? The this pointer is always passed around as the negative oneth argument, or the zeroth argument, where everything is slided over to make space for the this pointer. It is always implicitly passed on your behalf. Okay? Do you know how, for like vector-nu, and vector-dispose, and vector-nth, vector-append, you always pass in the address of the relevant struct, as the explicit zeroth parameter. Okay? Well, they just do not bother being explicit about it in C  plus   plus  because if they know that you are using this type of - if you are using that type of notation, you are really dealing with object orientation. What really happens, on your behalf, is that it basically calls the minky function, not with one variable, but with two. It actually the address of something that has to be a binky class, or a binky struct, as the zeroth argument. So whenever you see this in C  plus   plus , what is really happening is that it is doing this: it is calling the minky function, passing in the ampersand of b, and the ampersand of n. Okay? That happens to be an elaborately named function. And I am just going with the name spacing to make it clear that minky is defined inside binky. Okay? And I am writing it this way because even though we do not call it using that - that we do not use it - call it using this structure, right here, this is precisely how it is called at the assembly code level. Okay?

There is certainly an address of the first assembly code instruction that has anything to do with the allocation of this w variable. There is going to be an s p is equal to s p minus four, at the top of the assembly code that gets admitted on behalf of this. People believe that, I am assuming? Yes, no? Okay? The reason that C  plus   plus  compilers can just be augmented, at least the code admission port of it, can be augmented to really accommodate some parts of C  plus   plus  fairly easily, references and traditional method calls against an object, is that, whenever it see this, it says, "Okay, I know they mean this because they are being all LL about it. But they are really calling a block of code, okay, associated with the minky function inside the minky class, and I have to not only pass in ampersand of m as an explicit argument, but before that I have to splice in the address of the receiving object." Does that make sense? Okay. So the activation record that exists on behalf of any normal method inside a class, it always has one more parameter than you think But it still is gonna have a safe p c - I will write it right there - it is gonna have two parameters, on top of it. This right there, this would be the thing that is locally referred to as z. Okay? Below that, it would make space for this variable uptight int called w. This right here might point to something like that; it certainly would point to something like that in this scenario, right here. Does that make sense to people?

Because n - I am not using pure stack frame picture here - but because n is declared with a seventeen right there, this would obviously be declared and initialized that way. Okay? Make sense? This would point to some assembly kind code instruction associated with after that call, right there. So there is a little bit more to keep track of, but as long as you just understand that k argument methods - k just being some number - k argument methods really are just like k plus one argument functions. Okay? When we are thinking in terms of a paradigm, we do not actually wonder about how C and C  plus   plus  are similar. But when we have to write assembly code for something, we say, "Okay, I want to use the same code admission scheme for both C structs, with functions, and C  plus   plus  objects, with methods." You can use exactly the same scheme, the same memory model, for structs and classes, and function call, and function call and return, by just looking at k algorithmic methods, as if they are k plus one arguments functions, knowing that the zeroth argument always becomes the address of the relevant object. Okay? Does that make sense to people? When this, ultimately, calls this function right here, you understand that it is really equivalent to that. We just do not bother putting in the this pointer. Does that make sense? So internally, when I set up function call, or assembly code to actually jump to the binky colon colon donkey method, I actually have to make space for twelve bytes of parameters, eight bytes for two copies of winky. Make sense? And also, the this pointer. And because there is nothing in front of this method call, it just knows to propagate whatever value this is, and replicate it down here for the second method call that comes within the first one. Does that sit well with everybody? Okay?

Had I had a variable of type binky reference here, then - and I had done, like let is say I had done this - I cannot change the picture, but I am just improvising this one point. If I had done something like this: binky of d - binky reference d, and done this, then the address of whatever binky object d refers to would have to be the thing that is laid down in the this portion of the activation portion of the record for the donkey method. Okay? That make sense to every body? Yes, no. Got a nod; it does not tell me. Okay. So even though you think you are data-centric when you program in C  plus   plus , and you are verb function or procedure-centric, when you programming in C, the compilers really see them as just different syntaxes for exactly the same thing. Okay? And they ultimately become this stream of assembly code instructions that just get executed in sequence, with occasional jumps and returns back. And it just promises because the compiler makes sure that it can meet the promise. It just promises to emulate what the C - procedural C - or the object-oriented C  plus   plus  programmer intended to do. Okay? Make sense? Yeah.

Student:[Inaudible] use stasis?

Instructor (Jerry Cain):That is completely different. We do not see static methods too much in one hundred and six and one hundred and seven. You know how the word static seems to have, like, seventy-five different meanings? Well, it has a seventy-sixth meaning, whenever the word static decorates the definition of a method inside a class. Okay? I can go over this. Suppose I have a class called fraction, okay, and publicly, I have a constructor fraction where I pass in an int m and an int denom and I might even default the denominator to be one. So you can actually initialize fractions to pure integers. And I have this whole stream of methods. But then, I also have this one method inside, called reduce, which is intended to take a fraction that is stored as eight fourths and bring it down to two over one. Does that make sense to people?

Well, as part of that, typically what happens is that you will write some function: int greatest common divisor int x and int y, and they are still put inside the fraction class because it is seen - it might only be relevant to your fraction class. And you actually pass in these two parameters and it really just behaves as a function because it does not need the this pointer, in order to compute the greatest divisor that goes into x and y. So a lot of times, what you will do is you will mark it as static. And what that means in the context of a C  plus   plus  class, is that you do not need an instance of the class to actually invoke it. You can actually just invoke it as a stand-alone function. In fact, it really is a regular function that happens to be scoped inside the definition of a class as if it is just - as if the class has a name space around it. This is - I did not mean to put public here, I meant to put private. You remember how on - this is how similar static methods and functions really are. Remember Assignment two? Some of you had that headache of trying to pass in a method pointer to be searched, when it actually had to be a function pointer, and you are all like, "What is the difference. They are all the same to me." Static methods because they do not have this invisible this pointer being passed around, they really are internally recognized as regular functions. So if I wanted to define my act or compare function, not as a function but as a static method inside, I could have done that. I could have passed the address of a static function to b search. Does that make sense? Static method, I meant. Okay? Good? Okay. So static, I do not want to say you should avoid it. There are certainly places where static is usually a good thing to do. It interferes with your ability to use inheritance when you are dealing with C and C  plus   plus . You do not get inheritance and you do not get - you do not get the right thing, in terms of inheritance, when you are dealing with static methods. Which is why you do not see them as often. And normally, when things are written as methods inside a class like this, it is because they are actions against objects, as opposed to actions on behalf of the class, like this would be, right here. Okay? Any other questions? Okay. So next Tuesday, when we pick up on the normal discussion section cycle, you will get a section handout, where you will have some elaborate - I do not want to say elaborate - some meaty examples on C and C  plus   plus  code generation. I am only gonna test you on C code generation, with no objects, and no references on the mid-term, although it will be fair game on the final.

Next Wednesday, I will give out Assignment five; it will not be a programming assignment. It will be a written problem set, where you are not required to hand it in. You are just required to do it, and make sure that your answers sync up with the answers that I give out in the key. And it will be totally testable material. You are not - you are just required to effectively do it by six:fifty-ninepm, on Wednesday, May seventh. Okay? Does that make sense? So you have a full week to do this one assignment, which means you will all do it on Tuesday, May sixth. But you will have a week to actually kind of recover from the Assignment four experience, and learn all the pointer stuff. Okay? This make sense? What I want to do is I want to start talking, a little bit, about how compilation and linking works. We completely disguise compilation and linking with this one word called make. And it is just like - it is this magic verb like, "Just do it, and make it work for me." And somehow, it actually, usually does do that for us. But when you compile C code - C  plus   plus  codes as well - but C Code, I will focus on. It normally invokes the preprocessor, which is dedicated to dealing with pound define and pound includes. Then it invokes what is truly called the compiler. That is what is responsible for taking your dot C files, and your dot C C files, and generating all those dot o files, that happen to appear in your directory, after you type make. Make sense? And then, after compilation, there is this one thing you do not think about because code warrior, and x code, and visual studio C  plus   plus , they all make compilation look like it is the full effort to create an executable. But once all those dot o files are created, and one of the dot o files has code for the main function inside, there is this step called linking, which is responsible for taking a list of dot o files; stacking them on top of one another; making sure that any function call that could possibly ever happen during execution, is accounted for because there is code for that function one of the dot o files.

And then, it just wraps a dot out, or six degrees, or my executable, or whatever you want to call it, around the bundle of all of those dot o files. Does that make sense? Okay. Somebody had mentioned, the other day, that a line like this, why would not it be replaced by call of, like, p c plus four hundred and eighty, or p c minus one thousand, seven hundred and sixty? To actually jump to the actual p c relative address where the swap function starts, that actually will happen in response to the linking phase because everything is supposed to be available to build the executable file. And so if it knows where everything is, in every single dot o file, and it knows how they are being stacked up one on top of one another, they can replace things like this, with their p c relative addresses. Maybe, at the time that things are linked together, it knows that swap function happens to be the one defined rate above this. So when it calls swap, it actually calls p c minus , let is say ninety-six, or something like that. Okay? Make sense? Okay. Let me get some clean board space, and just spend five minutes, that is all I will be able to do, really, talking about the preprocessor.

And I am doing - okay, five minutes. Whenever you are dealing with pure C, if you wanted to declare global constants, traditionally until recently, you only had pound defines as the option for defining nice, meaningful top-level names for these magic numbers, or these magic strings. So something like this: pound define - I will just do k with, let is say it is four hundred and eighty pixels, so I write down four hundred and eighty. And then I have something like this, k height seven hundred and twenty. And then, I have some pound includes; I will talk about those later. And then, there is all this code right here, where usually, it is the case that some part of it is framed in terms of that and/or that. So maybe it is the case that you have a printout statement with is percent d backslash n -oops, right there - and then, you feed it the value of k width. Maybe a more meaningful thing might be something like int area is equal to k width times k height. And it exists in your code somewhere. When you feed, or when a dot C file is fed to GCC or G  plus   plus , there is a component of either GCC or G  plus   plus  called the preprocessor that does not do very much in terms of compilation. It does not do compilation, as you know it. It actually reads your - the dot C file that is fed to it, from top to bottom, left to right, like we would read a page. And every time it sees a pound define, it really only pays attention to these words. What it will normally do is, it will read in a line. And if there is nothing that has a hash at the beginning of the line, so it does not involve any pound defines or pound includes, it will just say, "Okay, I just read this one line, and I do not care about it. So I am just gonna publish it again as part of my output." When it reads something like this, it internally has something like a hash set, although it is probably - I do not want to say it is strong, eh, but it is probably strongly typed.

It associates this as a key with this string of text; it does not even really know that it is a number. Okay? It just says, "Everything between the white space that comes right after width, and the white space that comes after the first token, that is associated as a text stream with that identifier, right there." Okay? It does the same thing for that, right there, and as the preprocessor continues to read, every time it finds either that or that, in your code - the one exception being within a string constant - but everywhere else, it says, "Okay. Well, when I see that, they really meant that number right there." So it lays down four hundred and eighty, as if you typed it there explicitly. Does that make sense? Okay? You know the alternative would be to put lots of four hundred and eightys all over the code base, without using a pound define, or lots of seven hundred and twentys around the code base, without using a pound define. But then you change the dimensions of your rectangle, in your graphics program, or whatever. And then, you have to go through and search and replace all the four hundred and eightys, to make them five hundred and twentys or whatever. It makes some sense to consolidate that four hundred and eighty to a pound define, if the pound define is the only thing that is available to you. But the pound define is really very little more than pure token, search, and replace. Okay? Does that make sense to everybody? So the responsibility of the preprocessor is to read into the dot C file, and to actually output the same dot C file, where all the pound defines and other things, like pound includes, have been stripped out. And the side effects that come with pound defines have been implanted into the output. So this, right here, would be missing these two lines. Anything right here, that does not involve those two pound defines, would be output verbatim. This one line would be output verbatim, except that would have a four hundred and eighty replaced, right there. Okay? And this, right here, would have [inaudible], and that right there, it would probably have a four hundred and eighty times seven hundred and twenty. Although, the compiler might actually do the multiplication for you, if it is a very good compiler. Okay? Does that make sense? Actually, the - I am sorry - the preprocessor would not do that, though. This would just become four hundred and eighty times seven hundred and twenty. Okay? And the fact that it happens to be text - it is really text, at the moment - it is just that, when it is fed to the next phase of compilation, it will go ahead, and it will chew on those things, and recognize that they really are numbers. And that is when it might do the multiplication. Yeah?

Student:[Inaudible] define k width and then you declare a variable called k width underscore second, or whatever?

Instructor (Jerry Cain):Yeah, it will not do that. It has to be - it has to be recognized as a stand-alone token. So it I did this, for instance, like k width underscore two, something like that, it will not do sub - sub token replacement for you. It also will not do it within string constants, either. Okay? Okay. I am not done with the preprocessor yet, but I can certainly answer your question. Go ahead.

Student:[Inaudible] verbatim? [Inaudible] printouts?

Instructor (Jerry Cain):Yeah.

Student:What does the preprocessor do with that line?

Instructor (Jerry Cain):The preprocessor would, basically, output this line right here, except that the k width would have been replaced - spliced out and replaced with the four hundred and eighty. Okay? Which would be - it is supposed to be functionally equivalent. It is just allowing for the consolidation of magic numbers and constants. So whatever we want to use the pound defines for, to just consolidate all of this information at the top. Okay? Yep?

Student:[Inaudible] preprocessor [inaudible]

Instructor (Jerry Cain):It actually does not know the four hundred and eighty is a number yet. It is - it is - they just are incidentally digit characters, and that is it. But if I had done this, like that right there, the preprocessor would be, like, "Okay. I am just gonna take that six character string, and put it right there, and right there." And it is only later on, during real compilation, post preprocessor, that it will be, like, "Hey, you cannot do that." Okay? Does that make sense? Okay. And that would not happen. Okay. So come Monday, I will finish up the preprocessor. Pound defines are easy; pound includes are not. They are actually some involved with that. And then, I will talk about compilation and linking. Okay. I will see you on

[End of Audio]

Duration: fifty-one minutes



