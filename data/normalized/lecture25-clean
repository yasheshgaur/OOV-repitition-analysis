Programming Paradigm-Lecture twenty-five 

Instructor (Jerry Cain):Hey, we are on. Look at that. How would that happen? I have one handout for you today. Actually, I do not expect to get to the material today, but I do not see the disadvantage in giving it to you just in case you are bored over the weekend and have nothing else to do, you can read about XML and Python and networking.

What I want to do today is I want to focus a little bit more on dictionaries and show you an example where dictionaries actually contribute to a meaningful program. I am gonna re-write RSG from a sign of one in Python. We are gonna do it in laughably little space. I am gonna be able to illustrate a very small program that has the imperative, object oriented, and the functional paradigm all in it. Okay.

I will illustrate lamdas that they actually exist in Python and it is really just a matter of coming up - knowing the different syntax, the Python way of doing what you did in Scheme a week and a half ago or just until I guess last night or two nights ago rather. I also want to talk a little about objects and classes in Python, and talk about the object model.

It is very interesting to look at it because when you learn about objects and object orientation, and in a class like  one hundred and seven  where you look under the hood to figure out how these things are implemented, you can very easily get the impression like I did for years to be honest, that all objects, and everything is implemented the exact same way in all languages, and that is just not the case.

So I will talk a little about that today. With regard to dictionaries, I mentioned on, I guess it was Monday - what is today, Wednesday, sorry, Wednesday - that dictionaries are a central data structure in Python. They are basically a very simple syntax layer over what is very well understood to be a hash table.

They keys can be anything that are hashable. They do not even have to be heterogeneous. You can have some integers and some strings as your keys, and the things that they map to, the values, they can be any type whatsoever, and they do not have to be consistently the same type over the dictionary.

It is very amorphous, very heterogeneous, just like Scheme is with its data structures. You can put anything on a list, you can mix up data types you can do the same thing with Python structures. Okay.

What I want to do is I want to emphasize the fact that as opposed to C and C plus  plus  where you do not have a clear way to texturally initialize a data structure - like think about a C plus  plus  map or a C vector from Assignment  three  looks like after you have populated it with say  twenty  values. It actually depends on the binary representation of the data. Okay. And there is no way to say C plus  plus  vector of int is equal to  twelve thousand, three hundred and forty-five . Okay.

You do not have object literals in C or C plus  plus  or for that matter Java either. Okay. You can have array literals in Java in a way that you cannot in C and C plus  plus , but the real sophisticated containers, there is no real way to actually specify container constants. That is not the case with Python.

The first of three or four pieces of the RSG example - I will not write it out in full grammar, but what I am basically doing here is I am coming up with a file format for a random sentence generator grammar. You are familiar with this. I know it is been eight weeks ago, but you remember that it involved some angle brackets for non-terminals and things that were terminals were just normal strings. If I do this grammar I am actually writing Python code.

Now I will make it clearly a dictionary. I am going to have grammar that is just a gesture to what the full grammar could be like, but my grammar is going to be expressed as a dictionary literal where the keys are structured this way, and they map to arrays which are called lists in Python, or at least the way I use them I call them lists, lists of expansions. And for a start, I am only gonna have one expansion.

So here is the list. It happens to be a list of a length of one, and that item is itself a list, and I am gonna do it this way. It is not a very sexy sentence it is just a placeholder. This object is here. If I had a second or third option, they would have been common delimited list. I am not gonna have that for this one. I am just gonna have one option just so you see the structure in a small example, but I will let object map to a couple of options.

It can map to the standalone thing like computer. I will let it map to this par, this assignment. I am not interested in grammatically meaningful sentences; I am just interested in getting the grammar on the board. I think this is complicated enough. You look at this and you may think that there is really no other sensible way to do this, but realize that kind of like you have in Scheme that you are allowed to represent the data in serialized object form. Okay.

And that this actually gets grammar to be an in-memory dictionary where it has two keys and each one maps to a list of lists where this one happens to be a list of length one and this happens to be a list of length three. Does that make sense? Okay, I am being fastidious about the white spacing just because I am careful about it in the handout as well.

What I want to do is I basically want to conceptually expand the start symbol to generate a random sentence, and knowing that it is gonna select this, I am gonna want to expand this as a terminal, I am gonna wanna expand what is in there, I am gonna wanna expand what is in there. This and this are actually simple, it is just supposed to print. This is supposed to recursively do the same thing as if object is the start symbol, and it should expand to whatever it is supposed to expand to. Okay. Does that make sense?

Forget about the libraries, let me just invent function names. They happen to be the real function names. We are generating random numbers and names and things like that. Okay. If I assume that grammar is global variable. Just assume it is a global variable. We will correct that in a little bit. Just because we are dealing with Python does not mean we should just be lazy about globals, but just to illustrate all three paradigms at once right now. I wanna define this function def expand and I am just gonna call it symbol.

Now you know I do one of two different things depending on whether or not the symbol which I am just gonna assume is being cast in as either a terminal or non-terminal, and if it is a non-terminal then it is definitely in my grammar. If it is the case that symbol starts with this string which is incidentally the best way to represent a character. If that is the case then what I want to do is recognize that I do not want to print to the non-terminal, I want to select one of its definitions from its definition set randomly, and then basically expand, in order, all of the terms that make up the list. Okay. Does that make sense to people?

So all I am gonna do is this. Definitions is equal to the global grammar of this thing that I am assuming really in the grammar and no semicolon. Okay. That brings in this or this entire thing. Now there is a built-in which I am just gonna do this. I will just say expansion is equal to - there is a built-in function called choice which takes a list - it actually takes either an integer or a list. I am gonna give it a list. Choice is basically a get random function in Python as a built-in. If it is given an integer it gives you a number between zero and that integer exclusive just with random probability equal distribution.

If it gives you a list it selects anyone of the elements from the list with equal probability. That is kind of what I want. I want it to choose this, this or this with probability one third. I want it to choose that with probability one. That is exactly what this line is gonna do right here. Okay.

Now on Assignment  one  when you did it using C plus  plus , you did not necessarily use recursion. You probably used the iterator to just visit everything, but if you are thinking in terms of Scheme and how it dealt with lists, we did not use iteration there. We did not know about mapping technically when we did Assignment  one , but on behalf of something like this, if I understand that expanding this space will just print this space, and expanding space is here period we will just print to that after I get the else clause up here. Okay.

And I can also recursively expand that. I can do this map, the expand function, over what is locally recognized as the expansion so far. Okay. Does that make sense? So if this is capable of being levied against start with an angle bracket, it is certainly capable of being levied against that, and I am just gonna implement the else case where it is not a non-terminal to just do sys out write.

That is basically the equivalent of print out for [inaudible] and less than without any new lines, it is a raw character printer, where I will just print out the symbol. Ultimately every single non-terminal becomes a terminal or a series of terminals to be printed, so this is what is going to be doing the printing. Okay. Does that make sense?

Object orientation, clear imperative style, and I am electing to go with this functional Scheme-ish approach of actually looking at everything that is making up the expansion list as peers and having them all publish themselves whether there is recursion involved or not. Okay. Does that make sense to people?

As far as how to do this from the get-go, as a global function, I could actually call the seed function that just basically is like randomized from the CS one hundred and six  library set. We are just shaking up the dice a bit so that we really general pseudo random numbers, and do not start from the same number every time we run it. And then I might do something like this expand - now the handout version is a little bit cleaner about how it actually paginates the answers and things like that, but that is basically the gist of it. Okay. Does that make sense to people? Yes, no? Okay.

So what I want to do now is I want to bring the computer up. I am gonna talk about classes, and how to define classes in a second, but there is gonna be - I wanna emphasize some things that confused people last autumn when they did this DNA assignment, and it was more or less because I just did not mention these things specifically last autumn.

It was probably from me teaching Python for the first time last autumn when I just did not know what the problems to expect were going to be. This is in the handout. There is a clear output. You can actually run this. This is up in the CS one hundred and seven  Website underneath WWW you can go and actually find this if you want to and run it. Okay. Any questions about this before I divorce myself from this example? Yep?

Student:So to do recursion in this language then you have to call map?

Instructor (Jerry Cain):Oh absolutely no. I just elected to use map. If I wanted to write Fibonacci I could have a definition of Fibonacci and call it Fibonacci. If I wanted to, I could have done a four loop from  four I in range of zero though length of expansion, and I could have just called expand inside a four loop. I do not have to use, I mean, we can always make a direct recursive call in virtually any language that I know of. Okay.

I just elected to go with the map approach here because I think it is cleaner, and it is kind of the functional way of doing things. Not necessarily that that is the goal, but I am just illustrating all three paradigms in the same example. Okay. Question in the back? Student:

Could you repeat what C does again.

Instructor (Jerry Cain):Oh, C right here. Computers even though they - when they generate random numbers, they do so deterministically. Okay. So they are not really random, but there as seemingly random as a computer that is completely deterministic in its operation can be. Normally what happens, every time you launch the Python interpreter it uses zero or something related to zero to generate the first random number, and then it algorithmically uses prime number theory to generate the next sequence in the random number sequence.

If you always start from zero then you get the first same random number every time you run something, and you get the same second number every time you run something. You get the same sequence, and it kind of breaks the fallacy - I am sorry, it is exposes the fallacy that these are not really random numbers. That is actually not a bad thing. A lot of times I recommend getting rid of that when you are testing so you do get the same output every single time, and so you can really debut a lot more easily.

But C just says, you know what, just populate - just set it so the first random number that is going to be generated is related not to zero, but usually this is in the case of C, and I am sure it is the same in the case of Python that it usually takes the number of milliseconds or the number of seconds since the computer was turned on, and relates the first random number to that instead. This is basically the equivalent of s rand from C if you are familiar with that function. Okay. Yeah?

Student:[Inaudible]

Instructor (Jerry Cain):Yeah, they are right here. This seed and this choice, they are both from the same module, and technically if I am complete about everything up top, I should do this. I should do import sys - that is short for system obviously. It is because of that that I am allowed to go in and publish the console. And I could either import the random library and then do random.choice and random.seed or I could use the sexier way of doing it which is from random specifically import choice and seed.

And that is another way of doing it. Okay. It is just boilerplate, more boilerplate learning the language, things like that. Actually before I leave this example, I wanna do something. I would not write it this way, I am actually fine with the idea of grammar as a global here because it is just a little script, and it is really executing this as a statement, and then this as a statement, and then this as a statement. I do not really think of grammar as a global.

I think of the entire file as a function that it gets executed, but if you wanted to be a purist about this, and you did not want this right here to be a global variable, you could pass in the grammar like that. There is a little bit of a breakdown because now all of the sudden expand is a binary argument function as opposed to a unary argument function. That does not mesh too well with the way I have called map. Map and Scheme actually can deal with multiple lists depending on the arity of the function that is being mapped.

That is not the case with Python. This has to be a unary function. It does not have to be a named function. Okay. If I wanted frame the implementation and I wanted to frame this function, in terms of expand, but as a unary function I can do that using the Scheme idea lamdas. Lamdas actually exist in Python as well. What I can do, it is just syntax, I can invent a function right here. I am not just writing the Scheme code here, I am really writing Python.

Lambda, I will call it item for lack of a better word, and use a colon for the same reasons you use a colon every place else. Okay. And I just equate it with expand of item grammar. I will abbreviate that. That is the first argument. Do you understand how that is a one-argument function? Just believe the syntax, it is right. Okay.

It is scripted as an anonymous one-argument function whose implementation is framed in terms of that one argument, and this thing that it available as a local variable in the outer scope, and I want to map that over expansion. That is another way to do this, and it really has the functional components of Scheme that are interesting to me, and probably to a lot of people as it is mapping, and it has lamdas and the closures that come with lamdas. Okay. Does that make sense? Okay, good. Okay.

So what I want to do is I want to talk a little bit about the object model from a memory standpoint. I am gonna talk about this to a couple of degrees. I am just gonna worry about dictionaries at first. The manner in which dictionaries are passed around is precisely, at least for our purposes, precisely the same as the manner in which objects are passed around in Java. Everything is always passed around by alias or by reference. Okay.

So if I do this, let me just deal with lists because they are easier to draw, and I will just generalize the dictionaries. If I do this, it does not print anything out, but if I just print X, naturally it does this. If I do this, and then I print out Y, it prints out  one ,  two ,  three . Okay. That should not surprise you at all. Okay. There is some languages where what I am about to do would actually be different, but if I go ahead and call X, which is a list and I do append, and I append a  four , if I go ahead and print out X, you know for a fact that it is that, and that is not the least bit surprising.

You have logically updated X. However, what you may not realize is that X was evaluated, and the result of the evaluation was assigned a Y. All X did was it evaluated to the pointer, to the lead note on the list or the lead element in array. So when I go ahead and print this out, I am gonna get that because I changed Y behind its back when I actually updated X. Does that make sense to people? Yep, go ahead.

Student:[Inaudible]

Instructor (Jerry Cain):I will get to that in a second. It does not happen by default. You have to invoke one of two functions depending on whether it was just a one-level copy or a full deep copy is available to you. This is one thing I did not mention last autumn, and it caused problems. My particular solution to Assignment  eight  does not use any copying whatsoever. It just shared the same master dictionary throughout the entire implementation, but I should not have assumed that everyone would want to do it exactly the same way.

So you do need the ability, at least initially, until you convince otherwise, to be able to clone dictionaries. I am gonna talk about that in a second. Let me give you some sophisticated examples. If I set Z equal to the list, let is say  ten ,  twelve ,  fourteen , and I go out and print Z, it is of course going to be this, but then I do this. I will do W is equal to, and I will construct a list that way. Okay. Z and Z evaluates to the list  ten ,  twelve ,  fourteen . Okay. So when I go ahead and I print out W, not surprisingly, I get this. Okay.

I bet everyone believes that. What you might not recognize is that it does not make any deep copies. You do not transfer full ownership of the Z lists into the list that is owned by W. So if I do this, z.append  seventeen  and print out Z, it is now this, but more interestingly, if I print out W, I get this:  twelve ,  fourteen ,  seventeen ,  ten ,  twelve ,  fourteen ,  seventeen . These are obviously contrived examples that are very, very small, but it is illustrating - for some reason to me at least it was more mysterious because it felt like it was this higher level language, you did not necessarily know that objects were backing these things.

It was very easy to wonder whether or not it is a deep clone or a shallow clone, but almost always, at least initially, it just makes a shallow copy of it. Okay. It turns out that the shallow copy is preserved for the lifetime of the data in Python, and it happens to be different in a language called PHP which I use a lot at work where when you pass one dictionary around or one list around, it does not actually clone it, but it does actually label it [inaudible] it was copied from something else, so as you change it, it actually does a copy on write, and actually branches off the part that changes so that the two logically look different even though they are sharing memory. Okay.

None of that happens in Python though. Okay. If you want to make a copy, there is two ways you can do it. There is a module called copy. Okay. I suspect it is not written in Python. I am suspecting it is written in C, but I could import something called copy. There is actually another function I will talk about in a second. If you want to clone an object, X  equals   fourteen ,  fifteen ,  twenty-one , and you print out X, you will get  fourteen ,  fifteen ,  twenty-one .

If you do this, this is the same as all the prior examples and you print out Y, you get this, but that should not surprise you. This should not surprise you either. You do not know the syntax, but there is a key word in the language called is, X is Y is basically equality at the pointer level, and because X and Y really are aliasing the same exact physical memory, not only are they logic identical, but they are memory-wise identical as well, you expect this to come back with a true. Okay.

If you want to make a clone of something because you want to make some changes to a data structure without it affecting the original, you can do that. Z is equal to a functioned called copy, it is this copy right there that does it and I want to make a copy of X, not surprisingly Z is  fourteen ,  fifteen ,  twenty-one , but I am out of room, but if I did Z is X, I would actually get a false back because they are memory independent at least to some degree.

Now copy, you would think because it is called copy, that copy really means decline, do this depth first reversal and make sure every piece of memory that is generated on behalf of Z is independent from that that was accessible from X, that is not the case. This particular copy is what is known as a shallow copy, it only goes one level down. Okay.

So if I had a list of atoms, like I do right here, these really are fully memory independent, but if I were to have lists of lists of lists of lists - does that make sense? The top-level list would be replicated from a memory standpoint, but everything inside would just be a shallow copy. So it is almost like it generates new memory for the top-level array, but that does a mem copy behind the scenes for everything below that. Does that make sense to people when I say that?

If you really do want a deep copy, then you have to use this strangely named function called deep copy, and this is an interesting example. If I do M is equal to the list  one ,  two ,  three , I do N is equal to the list M, M, and that is good enough actually. Recognize that I have the list  one ,  two ,  three  in memory. That is my abbreviated version of showing the link list in memory, and this thing is associated with the variable M. Okay.

The link list that is generated on behalf of N is really this. Does that make sense the way I drew that? Okay. It is the same list that appears in Index  zero  and Index  one , but the same list is being pulled in two different scenarios. Okay. If I do this, P  equals  deep copy of M, which is interesting to me, not only does it do a recursive descent clone of everything, but if there are any cycles like there kind of our in this, forget about M, that does not interest me anymore. Do you understand why those two arrows point to the same  one ? Okay.

The deep copy not only figures out how to make a deep logical clone of the entire thing, but it actually figures out how to preserve the graph structure. Okay. Does that make sense to people when I say graph structure? Yes, no? Okay. So this would be associated with something that was completely independent, but would have the same aliasing internally. Okay. That is actually just a wise thing for it to do so that it can re-hydrate objects from their serializations if you ever wanted to go to that part of the Python language. Okay. Making sense?

Now it is - I am thinking that you do not need to use these functions for Assignment  eight , but whatever is said right here on behalf of lists, also applies to dictionaries. Okay. You use dictionaries and strings quite a bit in the Assignment  eight  solution. You do not have to use lists all that much at all. You can if you want to.

I use dictionaries to more or less bundle information that would otherwise be aggregated in a struct, like C and C plus  plus  would require it, and I use that to kind of aggregate information that is related to one another. Okay. That is I think a common practice in a lot of these dynamic modern languages. Python, certainly Perl to some degree, I do not know Perl as well, but Python I certainly know that is the case. I also know it is the case with PHP. Okay. So there is that.

What I want to do now, is I want to show you a little bit about objects and classes in Python, okay, and show you how they really are very little more than just dictionaries. Okay. This is gonna be interesting because - it is gonna be interesting to me, and hopefully it is interesting to you as well. Remember when we learned about the object representation? I am sorry, the activation record layout of a C struct, right.

You have a clear order in which fields are declared. You actually declare the fields ahead of time because there is a compile time element to it so you can bother doing that, and the first field goes at the bottom, the second field goes above that, the third field goes above that, etc. Okay. Objects and structs, classes and structs in C and C plus  plus , and actually classes in Java all adopt that model. All classes do is recognize that structs and classes can be the same thing, they both have data fields.

They do not store the method pointers or anything like that in the struct, they just lay things out according to the same exact formula. When you see something like that, you just assume that every language that is ever going to be invented from that point on is going to use exactly the same model. However, in a language like Scheme or Python, which have no compile time element whatsoever, you do not pre-declare the types ahead of time.

You just add stuff to these dictionaries which is basically Python is answer to the struct or the class. Okay. Does that make sense to people? And so you cannot specify an order of fields ahead of time because you are not even specifying the fields ahead of time. You just kind of add things to the dictionary as it is suitable for your algorithm, and if you add X, and then Y, and Z, but in some other execution you add Y and then Z, and then X, it should still logically have the same set of keys, they just happen to not be inserted in the same order.

Python and most modern languages, and to some degree Objective C, that is the Cocoa language for Apple, uses this for storing methods. They actually just put all the fields, and store them as strings in a dictionary. Okay. That is exactly what happens backing for dictionaries, and also for classes in Python which are backed by dictionaries, and we will get there in a second. Okay. So let me go ahead and just show you and example of a class, and I will do some tinkering at the command line.

Okay, this is good enough, and let is just focus on this right here. I do not think I can - that is not good. Okay. I will try to make the font bigger in the meantime. It might be too big, but we will correct it in a second. That is not bad actually. Is it up there? Now it is huge. Actually that is okay. That is a nice word over there. Let is bring it and make it nice good word. Okay.

That is good enough I think. I am not worried about the comment that is being clipped off, then I can bring this down, and that is all I am interested in. Okay. That is great. Actually it is like artwork. Okay. You see the class keyword that should just be immediately obvious to you that it is going to be defining some class in whatever sense Python defines classes.

You see this underscore underscore, and init underscore thing, that just means it is a special method. Not surprisingly it is related to construction. I will show you how to construct a lexicon object in a second. Remember how in C plus  plus , I probably said it this way about a millions times, and now it is a million and one, that it always silently passes the address of the receiving object as the negative one parameter, right.

Well, Python does not do that. It is very explicit about passing the address of the relevant container or object to all methods including the constructor. By convention it is called self, it does not have to be, but self is a keyword that is borrowed from Objective C, and I think that is right, yeah, actually it is. Objective C is self, it is basically just Python is equivalent of this right here. Okay.

Because objects are initialized dynamically, there is no compile time element whatsoever, it takes this empty object that really is a default object called object, that is part of the language, it is like java.lang.object, but you just add stuff to it, and what is happening here is that I have created two local variables, one is called in file, and one is called words.

From that point on it initializes fields, but these two lines right here, forget about them being inside a constructor, there just methods, f open happens to be the function that opens a file. Read lines is this built-in thing that actually takes an entire text file and builds an array where every single entry is populated with one line from the original file.

I am not gonna show you the file, you can just imagine that the words file that is opened by default is an alphabetically ordered list of all the English words in the language with no intervening white space except for the backslash N is for new lines. Okay. So I synthesize this right here. The read lines that actually preserves the backslash N which is really annoying, but it just does it, so what I do here is I introduce the first ever fields to the lexicon object by saying, you know what, you did not have anything before, but now you have this words field.

If it had it before it would just reinitialize it, and rebind it to something, but since I am taking a raw object, I am actually inserting one more thing into the dictionary that is backing the object, and it is initially set equal to the empty array. Okay. And then I just do brute force for looping. This is what is called an interable, it is actually an array. That is why I synthesize this right here. Okay.

And it just goes through, and it takes whatever words in that words array, truncates off the backslash N and puts it in the words array that is embedded inside the lexicon. Okay. Does that make sense to people? Okay. To whatever degree it is successful for you, just subscribe to your C plus  plus  and Java sensibilities as far as what constructors are for and what they are intended to do.

A lot of this is just different syntax. It has some quirks, its dynamics, but it does not have a class definition. There is no dot h file, there is no implied interface by a dot java file. It really is just this kind of deal with it as it runs type functionality, but nonetheless this entire thing is responsible for taking a raw object, and building it up to be a logically sound lexicon. If I just show you the next - oops, did not mean to do that, but I will bring it back in a second - the next method, it really is a method. It is a function definition that just happens to be - I am not sure I can get the entire thing in there - the def is over there on the left, but you can just look at this.

Self dot words, there is this bisect function, it is just like B search it is a little bit different. It is more like the lower bound function from C plus  plus  in that it just returns either the index of the matching element or the index where the thing could be inserted in order for it to maintain alphabetical ordering. I initialized the words array so that it was alphabetically ordered. All I am doing here is I am asking whether or not the word that is explicitly supplied when I invoke this contains word function, whether or not when I do a binary search for it, and get the insertion index for it, whether or not that actual slot in the words array matches the word I passed in.

So I am actually going to slide this over and see what the double equals is, whether or not it is equal to the word local variable. Okay. You get the gist of what I am attempting there? Okay. I have some other methods, I will just name them. They are not that algorithmically interesting. Word contains everything. I will show you how that works in a second. List all words containing. I will show you those in a second.

What I want to do is I want to bring my terminal back and show you how this works. Let me make sure I am in the right directory. I am, and I do in list to make sure I have words. I do. Let me invoke Python. This is how you deal with objects in Python. It is a little quirky, but there is a good narrative that can be made as to why things work the way they do.

If I want to use this lexicon class, just like all the functions inside divisors.py, and all the functions inside the copy module and random module and things like that, I have to import - I am sorry, from LEX, because this is all stored in lex.py, I want to import the class or the symbol, whatever functionality is associated with the symbol lexicon. Okay. And I do that and it works. I can do this, I do not want to use L, yes I will. I will spell it out, is equal to lexicon, just like that.

Student:[Inaudible]

Instructor (Jerry Cain):Oh, I am sorry, well, you can tell me. I did not do that. Okay. Do this. Wait, can you see it now? Barely.

Student:Yes.

Instructor (Jerry Cain):Okay. Now you cannot here me. This right here initializes, there is no new keyword in Python. The name of the class in this case is what is called a callable, and if you invoke it as a function it is a request to build an instance of that class. When I do this, it actually builds EL, I can do a couple things here. Lexicon, if you just type it in, it just reminds you that it is in fact a class. Here is one thing. Just to show you how relevant dictionaries are to the lexicon class, there is a special meta variable that is inside all objects, inside a lot of things, but in a particular object at the moment.

You ask for its dictionary - it looks like gibberish, but you see gestures to a lot of things. You see some weirdly named keys like underscore underscore, module, and underscore underscore init. Okay. Does that make sense? You can clearly see that they are keys in some dictionary the way the way it is scripted out. So the in-memory model of an actual class definition is a list of all the symbols that are embedded inside.

The ones that we created are underscore underscore init, and contains words and list all words containing, and contains all characters or whatever I called it or word contains everything. Okay. Does that make sense? So the actual class object is modeled by a dictionary. That does not happen in C or C plus  plus  at all. Everything is done in compile time, and it just generates all these  one  is and  zero  is that are consistent with the original definition of the class.

In Java there really is something like this, it is actually not a dictionary, it is a standalone class that gets stored in memory, but it is not that different from this right here, but there really is an in-memory representation of the class idea itself. I cannot show you EL; that would be a lot. Well, actually I will show you EL. If I do this, it tells you it is an instance of the lexicon in the LEX module.

When I do this, it is gonna show you the dictionary that is not associated with the lexicon class, but the dictionary that is associated with the instance of that class that I just created. Now this is gonna whiz by, it is gonna take a couple of seconds - actually that was not that bad. I cannot scroll up because we are dealing with a  one hundred and fifty , zero  zero  zero  words. Okay. Well, actually I could, but I am not going to.

What I will do is I will break the - oops, it did not like that, sorry. Okay. That is a little weird that I did that. Remember that words was a field that I introduced inside, there is no notion of privacy whatsoever in Java. You are only supposed to deal with that by policy, and understand that there probably are fields inside you are not supposed to touch. There is some way to actually mark something as intentionally private using underscores. I am not saying it is not used; it is kind of a hack.

There really is no enforced encapsulation in Python. It just relies on the programmer to be a good programmer, and to not touch inner fields or functionality that it does not think it needs to touch. But now if I do this you will not get the original dictionary, but you will get that right there. Okay. Before words had this array that went all the way through though zizzaba, and I just happened to empty it out. Okay.

But what I am illustrating here is that the object itself is backed by a dictionary and all the attributes, in this case there was only the words attribute, okay, but all those attributes are actually keys that are associated with some inner dictionary that is identified by an underscore underscore dict underscore underscore. Okay. Does that make sense? So you see how central the dictionary is to the Python language. Okay. I am guessing you do. Okay.

So there is that. What else to I want to do. Let is actually just, because it is fun, not because it is really important, let is rebuild the lexicon contains word hello, just to show that it actually works, it does. Okay. And then I wanna list all the words - I love doing this - all the words that have all the vowels. Oops, I did not do that. That is not - List all words containing - spelling right, yes, okay. Is not that neat? And it is very brute force. This is not the magic of Python, that is just they way I implemented it. It is just a regular class.

But the implementation of this is in the last page of the handout I gave out last time, the Python basics handout, and it is just a matter of gleaning syntax. I can tell you right now from experience that when you go out and get a programming job, it very well may be in C plus  plus  or Java, it may be in some language you have very little experience with, but you cannot be, um, I do not know how to do it. But binary search is mysterious in all other languages. It really is not.

It is just a matter of learning the other syntax and the idioms that the language supports for getting things like iteration and recursion and classes and structs and objects and all that kind of stuff down. Let is see if there is this. Just that one, and then obviously there is nothing else. Let is see if there is any words that have A, B, C, D, E, and F in them. That is not bad. Okay. N, G. Nope. Okay. Okay. So that is just playground stuff. That is kindergarten stuff just doing that. What I wanna do now is I wanna show you - let me just draw - I am trying to think if I wanna do some stuff. I do actually. Let me put this to bed.

What I wanna do is make a few remarks about the illusion of objects just being dictionaries. When you do something like this, let is say at the prompt you do O  equals  object. This is the equivalent of java.lang.object. You do that right there. You get absolutely nothing in response to this. You just get O is an instance of the object, but if you do this you actually get that right there. Does that make sense to people?

I am asking it to identify the collection of attributes that have been accumulated inside the object I am calling O or the instance of the object I am calling O. When I do this, and then I do this, and I do this, they are really instructions to insert a new value in the dictionary that is underscore underscore dict underscore underscore. So if I do this, I actually get three fields. I will assume they hash in this order. Okay.

When you do this you are not respecting capsulation. You are supposed to let methods do this, but I told you already that it does not respect any kind of privacy. There really is no support for privacy that is genuine and real. There is that, but doing these three lines right here is like doing this, and in fact it more or less translates to this. And then O dot underscore underscore dict underscore underscore c  equals  [inaudible].

This right here is syntactic sugar. It does not look like syntactic sugar, but it is in the case of Python, because this is just taken to be an instruction to not really try to do this, but to do that right there. It is really physically levying an operation against the dictionary that is inside of it. Okay.

So the takeaway point from this - I will talk a little bit more about this in the first five or ten minutes on Monday, but the takeaway point here is that the objects are backed by these growable, shrinkable containers, they have to be growable and shrinkable in ways that they do not have to be for C, C plus  plus , and Java because C, C plus  plus  and Java do all this wedding planning up front where everything has to be set in stone before any code executes whatsoever.

Python is a fully dynamic language. Everything is supposed to be able to grow and shrink. Everything about it is supposed to be dynamic, so you are not supposed to impose limits on how big something can be unless it is an implementation limit like you just cannot store more than like  two  to the  twelve th keys in a dictionary or something like that. Okay. So activation record as an idea, it works beautifully for C and C plus  plus  where it can actually do all the scrubbing up front, but for Python it cannot; it has to back all the objects with a different model, and this is exactly how it does it.

Okay. So you definitely have enough information to crank through Assignment  eight . Come Monday, I wanna talk a very little about inheritance. I know you know a little bit of inheritance from either AP Java or from  one hundred and six A. Okay. If you have taken  one hundred and eight , then everything will be easy. But I will just talk a little about inheritance and how it is relevant to some of the, I think, more interesting ways of doing networking operations which is what this handout I gave out today is all about. Okay. So you guys have a good weekend, and I will see you Monday.

[End of Audio]

Duration:  forty-nine  minutes



