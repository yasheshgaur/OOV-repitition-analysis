Programming Paradigm-Lecturezerothree

Instructor (Jerry Cain):Hey everyone. I have one handout for you today. You do not have it in your hands because we are gonna pass it around. I just really have the one. I am gonna have T.A.s pass it around during the lecture. I sent out an email on Saturday. Did anyone not get that email? Probably a handful. Oh, wow, nobody - everybody got it. That is great. Okay, you did not get it - the email? Okay. Well, if you can, like, email me directly after class so I can figure out what the deal is. The reason I say that is because I just realized over the weekend - this is totally my fault - that the section room for tomorrow, Skilling one hundred and eighty-three, seats forty-eight people. And I am telling everybody to go to it. So I have some - I have to figure something out there. Normally that is going to be fine because most of you will just watch it on TV and get in the habit of doing that. But tomorrow I kinda want you to go. So I am working on one of two solutions. I am either gonna try and get a bigger room just for tomorrow for four:fifteen, or I am gonna get a huge room at three:fifteen, still have the four:fifteen section, and try and push everyone to go to the earlier one if they have any flexibility. So I will make a decision as to what - based on what rooms are available to me later today. And I will send out an email, which is why I am asking about the email. Okay? So definitely stay tuned for a CSone hundred and seven email after today. When I left you -what? Question right there.

Student:What was the time again?

Instructor (Jerry Cain):Tuesday at four:fifteen are the normal sections. I may have one - may is the operative verb there - I may have one tomorrow at three:fifteen, just tomorrow, to accommodate the sheer number of people I expect to show up. Okay? When I left you last time, I was doing little asterisk and ampersand tricks. Let me do another one. I have a double D, and I set equal to three.one thousand, four hundred and sixteen. And as a result, I actually get a fairly large figure in memory that is populated with pi. We will decorate this with a D variable. And if I go ahead and do the following, CAR CH is equal to asterisk, CAR star, ampersand of D - there was a little bit of confusion about this. Because of that ampersand operation right there, the actual bit pattern that resides in the eight-byte figure that we are calling D, the bit pattern is actually irrelevant. This is an expression on the address of D. It does not have to look inside the eight boxes to figure out what is important here. It has to evaluate that address because that is there. It is seduced into thinking that it is actually storing the address - I am sorry, that' it is an address of a single character. So when it is dereferences this right here, it goes and it embraces that single byte right there. Whatever bit pattern happened to reside there before is now pretending to be a character for the lifetime of this statement right here. Does that make sense to people? So if this happened to be - I do not know what it is - but suppose it is this bit pattern right there, okay? This variable called CH will get that very bit pattern. And if I go ahead and do cout << CH << ENDL, whatever this corresponds to gets printed to the console. Okay. That make sense to people? Okay, let me do one more little tricky thing here. If I declare a short, and I set it equal to forty-five, I get a two-byte figure that has a forty-five in it. It is stored in binary, but I am just gonna write forty-five because it is easier to look at that. And I do this; this is where you get into a little bit of danger. Double star - I am sorry, double D is equal to asterisk of double star ampersand of S. Most of what I have said prior applies here as well. This is one scenario where things are a little bit mysterious. This right here evaluates to the ampersand of S. That is the address associated with that arrow, the number associated with that arrow. And this is a brute force reinterpretation of that address. So what is gonna happen is it is gonna say oh wow, that arrow now - it never pointed to a short. It actually points to an eight-byte double. So it will go, and not only include those two bytes right there, but the six bytes that follow it. Okay? Whatever bit pattern happens to reside there, provided there is no memory crash - and I will explain why that could happen in a second. As long as it gets away with it, it is gonna go and embrace all eight bytes of those - eight bytes of information there, interpret it as an eight-byte double, and then assign it to this thing called D. So if this is a forty-five, followed by that as a byte pattern, then D would get forty-five with this as a byte pattern. And when I print that out, it is gonna print out whatever number happens to be associated with that representation. Does that make sense to people? Okay. Now, I could do these for days, okay? And show you every little combination between asterisks and ampersands and double asterisks and whatnot. I want to move on and start talking about arrays and structs first because I think you will just get more practice there. We will start learning some more material. There was a question right here?

Student:Yeah. Are these examples gonna behave differently on low NDN?

Instructor (Jerry Cain):Certainly, yeah. The - well, as far as the bit copying is concerned, no. This ampersand, right here, is always the address of the lowest byte. But as far as how the - NDNS has to do more with interpretation and placement of bytes relevant to one another. As far as - there was these phrases in the handout that I kind of de-emphasized, but they are there. And since your asking, I will talk about it. Little NDN. If I were to write down a two-byte short like that, and if I were to store the number one in that short, you would just say, "Oh, well the one just goes right here, and it is proceeded by fifteen zeros." Does that make sense to people? Okay. That is true on about half of the systems in existence at the moment. This right here - not only is a representation for positive one as a two-byte short - it happens to be stored in what is called big NDN format. And the best way to remember that - it is kind of arbitrary as to what big versus little means in this context. I just remember it as the lowest byte stores the bits that correspond to the largest contributions of magnitude. Does that make sense? Okay. And since on is such a small number, that is why you have all these ones over here. On some machines, in particular the Linux machines that you are probably working on, it would store this with the bytes in the reverse order. Okay? It would actually have the one right there, proceeded by seven zeros, followed by eight zeros right there. And it is just when it goes it interprets it as two-bye short. It actually assumes that these are bits zero through seven. And these are bits eight through fifteen. Does that make sense? So if you actually were to - and you could do this if you wanted to - if you were to copy a two-byte short from a Linux machine to Solaris machine, and just do it on a byte copy level, you would not get the same numbers on different machines. Okay, you would get one on a bit NDN machine here. You get two hundred and fifty-six - I am sorry - yeah two hundred and fifty-six on little NDN machine. Does that make sense to people?

Okay. For the most part you do not have to worry about NDNS at all. There is one aspect in assignment two that happens to deal with it, but I am more or less insulate you from it. Okay? Just something to be sensitive to. What I want to talk about now are structs, how they work. How arrays work. How arrays of structs, structs with arrays inside all work. Given what we know already - let is kill this. Let me go ahead and declare this as a struct right here. Very simple. Struct fraction int num int denom. That right there, that is the C way - I will assume we are in C plus  plus  for the moment. That is enough to declare fractions stand alone as a new type. If I do this, fraction - let is say pi as a variable name. As a result of that, I obviously get enough memory to store a fraction. In one hundred and sixB and one hundred and sixX, and maybe one hundred and sixA as well, you drew them as the somewhat loose rectangles around two boxes. Okay, I want to be a little bit more structured than that. I want to recognize that the amount of memory that is set aside for the struct fraction, not surprisingly, is eight bytes. Okay? It is basically the sum of some of its parts, and it actually packs all of those bytes as tightly as possible. I am gonna draw this as eight bytes. I am gonna emphasize the fact that it is really four byte stacks on top of four more bytes. The address of the entire struct is always coincident with the address of the first field. So looking at this, and assuming that that is a picture of one of these things, you know that this is the num field. In this case, it will be pi dot num because that is the way I declared it right there. And stacked on top of that, four bytes above the base address of the entire thing, would bit pi dot denom. Okay? So when I draw that arrow right there, unless they give you some context, you do not know whether it is an int star pointing to the address of the num field - I am sorry, storing the address of the num field or the address of the entire struct. Okay? When I do this, not surprisingly, that places a twenty-two in the lower four bytes of the entire figure. The more technically accurate way of saying it is that it actually stores a twenty-two to the field that is at an offset of zero from the base address of the entire struct. Okay? That is why twenty-two gets placed there. When I do this and store a seven some where - because it recognizes base on this definition, which it certainly sees before it sees this line right here, it knows that denom is stacked on top of num because num is a four-byte integer, but denom is four bytes above the base address of the entire thing. And that is how it knows where to put the twenty-nine zeros followed by three ones for the seven. Okay? If I go ahead and do this - this is where things get crazy - if I go ahead and do this, ampersand of pi dot denom. I will do that. You do not technically need it, but that makes it clear what you are taking the address of. I have an int star, right, unless I do this. Okay? And now I have the address of a fraction. So what happens is just on the fly, it stops thinking about this address right there as a stand-alone integer, or pointing to a stand-alone integer. Now it has this picture, all of a sudden, at the moment that it is addressing this eight-byte picture that overlays that space right there. So when I go ahead - let me actually draw this a little bit more accurately. I go ahead and do fraction, asterisk, and I do this, num is equal to twelve. The arrow comes after something that at that moment is assumed to be the address of an entire fraction struct. So the arrow travels to that struct. There is not much traveling to do because it is already there. And then it goes inside and identifies the num field as the place that should receive the twelve. Where is that num field? It is right here. Does that make sense to people? Okay. So if I go ahead and I just print out cout << pi dot denom, behind pi dot denom is back, it was changed from a seven to a twelve. Okay? If I do the same exact thing, fraction, star, ampersand of pi dot denom, arrow denom is equal to thirty-three, it is going to - it is not going to be concerned about the fact that I really do not own the space above what is truly pi dot denom. The way the mechanics work takes the base address of this. Oh look, it is a fraction star now. Go four bytes beyond that to find out where the thirty-three belongs. It is gonna smear down the four-byte representation of thirty-three in this space right here. And there is no legal way to get to it and print it out, but if I did this again to the right of a cout statement, it would print out a thirty-three. Does that make sense to people? Okay. Good. Let me do one more thing. Actually, let is not. Let is go on to arrays. Int array. Very different from Java. We did not talk about arrays in CSone hundred and sixB and one hundred and sixX as much as we will in one hundred and seven. Question in the back?

Student:Yeah. Sir, I do not know if I caught you correctly, but did you say that when you set the fraction and then ampersand, p dot denom, the num to twelve, does that mean when you access pi dot num - or sorry, pi dot denom that it is gonna be twelve and [inaudible].

Instructor (Jerry Cain):That is correct. Right. You happen to invade pi dot denom is space using some quirky syntax. Okay? Just because you happen to know that pi cot denom resides above pi dot num, just because you reinterpret the address to be associated with a different data type, if you happen to operate on space that overlays the original pi dot denom, then you are affecting what really is pi dot denom is value.

Student:So is there to access the denominator - or the denom of the four-byte representation within the four-byte representation?

Instructor (Jerry Cain):Within the -

Student:How - basically, how can you access that thirty-three without doing another [inaudible].

Instructor (Jerry Cain):You actually cannot. I am sorry, you certainly could use this expression again to do so.

Student:You cannot access it any other way?

Instructor (Jerry Cain):If you wanted to - I mean this will be more clear after I do the array example, but if I wanted to - since you are asking - pi dot denom, fraction star. Okay? Do you understand that that is the address of the top two thirds of the drawing? What I could do is I could do something like this. That is a little sneaky. That will be clear after I do the formal array example that I am covering up right now. But that is effectively a dereference to go and get to the denom field. Okay? I would not even have to do this necessarily. I could just do address of pi of one dot num is equal to, or print that out or something like that. Okay? I mean this will become more clear after I talk about the array business a little bit.

Student:Because what is at the one index is actually a fraction?

Instructor (Jerry Cain):It literally is eight bytes beyond what is at the zero index. Okay? You do not get that; do not worry. I will start with a simpler example right here. This right here, you know this already. It allocates forty bytes of memory, okay, for the ten bytes that are being set aside and under the jurisdiction of this key word called "array." So I am going to draw it this way, and do a module of five - spit it out. You know that this is a zero index, and you assigned to it using an array of zero. This is an array of nine. So when I go ahead and do something like this, array of zero is equal to forty-four. I put a forty-four there. You know this. If I do array of nine is equal to one hundred, and one hundred goes there. What you may not recognize is that array itself is synonymous with the address of the zeroth entry. Okay? Let me write that down as, like, a little - like a little theorem. In the context of that declaration right there, array is completely synonymous with ampersand of array of zero. Okay. That is why when you pass an array to a helper function, or any function whatsoever, you are not passing the entire array, you are just identifying the location of the zeroth entry, and from that you can access anything legitimately beyond it, as long as you know how long the array is. Okay? If I go ahead and do this, let is create some tension.

forty-five, and obviously zero, one, two, three, four, five, that is nothing new. If I go ahead and mess up, and I do not understand four loops, and I do not understand arrays well enough to not make this mistake yet. If I go ahead and I write down the number one, it is consistent with the offsetting that is done relative to the base address of the entire thing. This right here assigns a forty-four to the int that is at zero ints forwards of the base address. Go ahead nine quantums of integers to find out where the one hundredth should go. Go ahead five. Java is a different story, but in C and C plus  plus , there is no bounce checking done at all on raw arrays, and that is exactly what this thing is right here. So, when I do this, it really says, oh. Well, that is interested in that address right there. This is ten is interpreted to be ten times the size of an integer, which is four, for a forty-byte offset from the base address right here. So it goes right there, and it leaps forward forty bytes to the base address of what it has no choice but to assume is an integer space. So it is going to go down. Whether it is going to cause problems or not is a different story. It will try and place a one right there. Okay? If I do this, f twenty-five is equal to twenty-five, and somewhere over here, a twenty-five is laid down. Okay? It actually even tolerates negative numbers. It is that brute force - I do not want to put zero. That is not very useful, seventy-seven. It would march back one, two, three, four places to figure out where to place this seventy-seven, and that is how memory as a side effect would be updated by these bogus little statements right there. Okay? Does that make sense? Question in the back?

Student:[Inaudible] make the assignment of the right ten if it is going to do that anyway?

Instructor (Jerry Cain):I am not sure what you mean. Say it again.

Student:Say an array ten, like, you initialize it ten by spaces, but like, what is the point of initializing it if it is just going to do what is - basically do what you want when you get inside of it.

Instructor (Jerry Cain):That is true, actually. This right here is really just documentation for how much space is being allocated. And then you are supposed to write code - I am not saying this is good code. I am just saying its code. Okay? You are supposed to write code that is consistent with the amount of space that you legally have. But this, this, and this just work because there is no bounce checking. It does not look arbitrarily far backwards to figure out whether or not it is an in-range index. So when it gets away with this, and it compiles, and it runs, it is just gonna put a one where it assumes that the eleventh entry would be, or the twenty-sixth entry, or the negative fourth entry. Okay? Does that make sense to people? Does that make sense? Okay. Yep?

Student:[Inaudible] the memory?

Instructor (Jerry Cain):It does not in C and C plus  plus , not at all. All it does is instruction for that one declaration as to how much - how many variables, more or less to - I am sorry, how many ints to set aside space for. But once you do that, like, there is no - the length of the array is that. But the length of the memory figure, it is not exposed to you. So there is no way to recover it. That is why you always pass around the length, width, a raw array in C and C plus  plus . Okay? You use vectors more than you did raw arrays in C in one hundred and sixB, but we are gonna be more C programmers than C plus  plus  programmers for the next few weeks, so we do not have vectors because we do not have classes. And we do not have templates. So we actually have to take this approach right here. Okay? Yep?

Student:So you use the address of pi and the X sets it as an array there. Is it gonna know that the sides of each element is a fraction?

Instructor (Jerry Cain):Yep. That is - it uses the data typing of whatever pi is right there, and because ampersand of pi is an int star, it knows that if you automatically - if you just all of a sudden start treating it as the base address of an array, even if it is really only an array of length one, it is gonna deal with the default offset of eight because that is how many bytes are in a fraction. Okay? So this will become a little bit more clear after I put a few more little theorems over there. Okay? When you do this right here - let is say it this way. Array of K, where K is an arbitrary integer, it is - the address of that thing is completely synonymous -- and you did not see this all that much, if at all in one hundred and six. It is synonymous with this right here. Okay. So the first line is not array so much as it is array plus zero on the left hand side. Okay? This right here, given that example, array is of type int star. There is no storage for array. It is not like the address, the base address of the array is stored anywhere that you can manipulate. But this is of type int star. If this is assumed to be an integer, which it is in this example, then you are not doing normal arithmetic here. You are doing what is called pointer arithmetic. And it knows that you are not going to be dealing with arbitrary bytes inside an array. You are only supposed to be concerned with the boundaries that separate the space where one int ends and another one begins. So whenever this is understood to be a pointer right here, this number is not added verbatim. It is automatically scaled by the size of the figure being addressed. And it knows what the figure is based on the type system. In this case, it knows that it is pointed to an int. That is why there is - those are four bytes. That is why all these rectangles are seemingly four bytes wide. In this example up here, ampersand of pi evaluates to fraction star. So when I start treating it like it is an array even though it is not, I have no choice but to rely on this rule right here to figure out where the oneth, counting from zero, fraction would be, starting at this address. Okay? And that is why it advanced eight bytes beyond the base of that entire drawing to figure out where to start dealing with things. Okay? Does that sit well with everybody? Yes? Yep?

Student:Is there any way to get access [inaudible].

Instructor (Jerry Cain):There is. You can actually use some casting tricks. I will do that in a second, okay? I will do that, like, probably in two or three minutes, but I will do a really good example for that question. Okay? What I hope is a good example. I should say it that way.

Student:Permission for the array [inaudible].

Instructor (Jerry Cain):That is correct.

Student:[Inaudible].

Instructor (Jerry Cain):That is correct. So just because I write a one here and I have code that actually tries to do it, does not mean that while it is running, it is gonna succeed. If it succeeds, it does place the bit pattern for one there. It might also crash. Okay? Or it might actually succeed. But this space right here? We will see this very shortly. This space right here and this space right here is gonna be associated with other local variables that happen to be declared above this and below this. There is no impact here because this is the only declaration. But if I were to declare int I right there, and double D right there, the model we are going to use - and this is the model that is really used - is gonna packs all local variables into a little thing called an activation record. That is just fancy terminology for the block of memory that is set aside for all local variables in a function. So if you touch this right here, you are really touching some other local variable. You are touching the one over here that was declared after the array. This is the way it kind of works out. Okay? Does that make sense? Okay. There is a couple more rules I want to talk about here. When you dereference this right here, if you put an asterisk in front of this ampersand, they kind of negate one another. So this is synonymous with array of zero. The extension of that for this line is that if I put an asterisk in front of this, the pointer arithmetic is done first so it computes the address of the integer you are interested in, and then the asterisk actually brings you into that rectangle. It is synonymous with that right there. So that is why when you do something like array of negative four, you are really doing this. Oops. Pointer arithmetic brings you not four bytes before, but sixteen bytes before that address.

You dereference it to actually sit in, and find yourself in a rectangle that is capable of receiving the seventy-seven. Does that make sense to everybody? Okay. That is great. So in a second I will start mixing arrays and structs, but to get to your point with regards to how do you access the internals if you want to do it. You rarely want to do it, although there are - actually it turns out that there are features of assignment two that rely on this type of knowledge. I am not encouraging you to write this code, but I do not see the disadvantage of understanding it. If I go ahead and declare, let is say, an int array - I will keep it small - five. Oops. I get this right here, one, two three, four. If I go ahead and set array of three equal to - let me do one hundred and twenty-eight. Uninitialized, left uninitialized, left uninitialized, left uninitialized. I actually put a one hundred and twenty-eight there, and I am drawing in the right half of the box because that is really where the bits will be updated. Everything to the left of the one hundred and twenty-eight, right here, will be all zeros. And this will be one followed by seven zeros. I am just emphasizing the fact that the one hundred and twenty-eight happens to fit in the lower of the two bytes. Okay? If I do this, the data type of that is int star, right, unless I do this. Okay? Now, ARR is brainwashed momentarily into thinking that it addresses a short. And there, incidentally, is space for ten shorts there. Okay? The way ARR, or the way the result of that expression sees it, that is short of zero, short of one, short of two, short of three, short of four, short of five, short of six. Make sense? Okay? This is kind of what you were getting at, I am assuming. Zero, one, zero, two, four, six. It is gonna write a two in that byte right there. Okay? So when I go ahead and I cout << ARR of three << ENDL, you are not printing out a one hundred and twenty-eight. You are actually printing out five hundred and twelve plus one hundred and twenty-eight. Everyone know where the - where I am recovering that five hundred and twelve value from? Okay. If this is the number two, and I multiply it by two eight times to get into that position right there, that is really two to the ninth plus two to the seventh. Okay? And so it is going to print out whatever that number is right here. Okay? I can go arbitrarily nuts with all of this casting. If I wanted to set ARR of one address, and I want to cast that to be a CAR star, I want to add eight to that, and I want to cast that to be a short star. And I want to find the third short after that and set it equal to one hundred. I think I have the patience to go through with this and show you what is going on right here. ARR of one is that box right there, so the ampersand is that right there. Pretend just for me that you are a CAR star so I can do something funky and add eight to you, but have it mean eight time the size of CAR plus two plus four plus six plus eight. So that is the address of this right here. Okay? You are a CAR star. No, you are not. You are a short star. Okay? Pretend you are the base address of an array. I do not care how long of an array it is. Just go three shorts forward of that short star that is right there to figure out where to write a one hundred. This is the zeroth one. This is the oneth one, the twoth one. The third one. This is where the one hundred would go. Okay? Do not write code like this; just understand it. Okay? This make sense to people now? Okay. Let me start blending structs and fractions to get more interesting examples. We are - come Wednesday, we are gonna be able to do meaningful stuff with this knowledge. Right now it is all gibberish, and it seems like it is just contrived code. It is certainly contrived code because the examples need to be small and focused.

But once we understand how to deal with memory - and that is what we are really doing with all of these examples - you will be able to take the understanding of memory and write meaningful generic code in C. C we do not have templates. That is how we dealt with generics in C plus  plus . In C we have to leverage off - over the fact that we know the size of everything, and we know that bit patterns represent vales to be able to write a generic binary search, or a generic linear search, or a generic swap function, or a generic vector, or things like that. Okay? And that is what Wednesday and Friday, and probably next Monday are going to be all about. Did you get this example? Okay. You will - if you do not get it yet, section handout come next Tuesday, not tomorrow, will deal with more of this stuff. Okay? Let me go on to structs with arrays in side of them. I am gonna need two boards. That is why I am erasing so much. I should just erase with the chalk. Here is the struct definition I want to deal with. Struct student. Okay? I have a field inside. I want to store an exposed character pointer. You are not used to doing this because you had a string class in C plus  plus . We actually do not have those in pure C. They are always represented as character arrays, okay, where the characters in the string are laid out side by side. Rather than there being a period at the end, there is what is called a "null character," The backside zero character that is at the end. This one is gonna happen to reside as a string outside the struct. All I want to do is I want to store the address of the zero character of the entire name. That is different from this, SUID of eight. I want to store the individual digits of a seven-digit SUID in an array that is wedged inside the struct. This will become clear from a picture in a second. And then at the bottom I just want a normal integer num units. And there we have our definition. Okay? What is a picture of one these things look like? It looks like this right here. There is my CAR star. There is my static character array of length eight. And there is my num units field. So this is a sixteen-byte struct, okay? You are not used to looking at these things this way, but in memory diagrams, at least usually - at least for the next day, you read left to right, bottom to top because you are always worried about the lower addresses. The address of the entire struct is coincident with the address of that CAR star. Okay? So to see this arrow, you do not actually know whether or not it is a student star or a CAR star star. Yes, we will be dealing with double pointers. Okay? If I go ahead and declare four of these things in an array, student, pupils of four, then I get four of those things laid out side-by-side. The way of laying down the elements, the base elements of an array, is the same whether you are dealing with Booleans or ints or doubles or structs. So actually you are gonna have four of these things. Draw those right there to make it clear that we are - that is the zeroth, the oneth, the twoth, the third. Okay. So I have all sixty-four bytes of memory for my packed array of four items. Each item is a struct, and the same skeleton, or the same view of memory, overlays each of the four quantum elements.

So when I do this, pupils of zero dot num units equals twenty-one, you know that twenty-one goes somewhere, and this is not too bad. You know it is gonna go in the space that is dedicated to the num units field of the very first student struct. Okay? If I do this, pupils of two dot, let is say, name is equal to - there is this function I want to talk about - strdup Atom. S-T-R-D-U-P, strdup is actually shorthand for string duplicate. Okay? So what this does as a function is it dynamically allocates just enough space to store the string - in this case Atom - and then it actually writes down Atom in that space, and as a function returns the address of the capital A. Okay? These four things right here are all local variables - I am sorry, the entire array is a local variable. It resides in a part of memory called the stack. I am assuming you have heard of the word "stack" before. You may not have heard it talked about in the case of memory. But the dynamically allocated string - and this is dynamically allocated - that is drawn from a part of memory called the "heap." Logically, we assume that it is five bytes. It actually makes space for that backslash zero. Okay? And then the address of that new figure right there, after it is been initialized with whatever this string logically is, gets returned, and it is dropped in the name field of the third, counting from zero, okay, struct. So this gets placed right there. Okay? That is very different than this type of setup, where pupils of three dot name is equal to pupils of zero dot SUID plus, let is say, plus six. There is a lot going on in that line. Let is just look at the right hand side, pupils of zero dot SUID. Pupils of zero SUID of zero is that right there. Pupils SUID of four is right there, but I do not have any array index dereference going on there. I have just the raw array name right there. That is synonymous with that arrow right there. In spite of the fact that this is a big, nasty expression that evaluates to a pointer, when I add six to it, it is doing pointer arithmetic against a CAR star. Okay? So the six is effectively, even though it does not matter, it is scaled by the size of a character, which is one. And so the overall right-hand side expression is the address of that character right there. Does that make sense to people? Okay. The tale of that arrow is assigned right there. All I did was I assigned an actual value to the name field of the very last student in that record. It happens to be the address of something that resides inside the entire figure. Okay? If I do this, pupils of one - oops, messed up. Str - not dup - cpy of pupils of one dot SUID four zero four one five XX. Right there. Strcpy is like strdup, except it does not actually allocate any memory. It assumes the address where you should copy the string is identified by the first arguments. So what this does is beneath the surface - in strdup as well, but specifically in strcpy - there is some little four loop that keeps on copying characters one after another until it finds a backslash zero, and it copies that as well. In fact, strdup, after it calls C is equivalent of operator new, which is called malick; it actually calls strcpy. This right here, on this one-by-one basis would write a four right there. And then a zero, and then a four, and then a one, a five, an X, an X, and a backslash zero would be written right there, and then it would return. And it is completely useful because of its side effect of copying characters around. You have to make sure that the address you pass in there actually points to character space that is really under your jurisdiction because it is gonna try and write characters to whatever address that is specified there. You better make sure it is a good address. Okay? This one right here, strcpy again, of pupils of three dot name, one, two, three, four, five, six. - and that is enough; do not worry about the fact that that is not really a Stanford ID. It was seventy years ago, I am sure. Pupils of three dot name. That evaluates to whatever this evaluates to. That means that location right there, okay, is what is identified as the place where characters should be written. Okay? It follows exactly the same recipe that the first called of strcpy did. It is not as if this byte and this byte are auto-declarated behind the scenes as things that can always store characters. And it is not as if that is turned off right here. As far as strcpy is concerned, it sees this as a base address of an arbitrarily long character sequence space where characters can be written. And so what is going to happen is it is going to write the digit character one right there. It is going to write the digit character two right there.

It is gonna do exactly the same thing right there with a three, a four, a five, and a six. It is gonna write a backslash zero - oops, not there - in the left-most byte of that name field right there. Okay? Does that make sense? And then strcpy is, like, I did my job. I am awesome. I am gonna return back to the main function. So when you come back, if you want to print out the number of units this student was taking, it is a lot. Okay? It is three times to the twenty-fourth plus four times two to the sixteenth plus five times two to the eighth plus six. They would have to petition to do that. Okay? If I go ahead and I print out this string right here, and I actually pass this in, if I do cout << pupils of three dot name, it actually would print one, two, three, four, five, six, and that is it. Okay? That is because it just receives the address of something it trusts to be a character followed by probably another one followed by yet another one. It just crawls over consecutive bytes of memory until it incidentally finds one with a zero in it. Does that make sense to everybody? Okay. Again, you will not be writing code like this, okay, but you should be able to understand, at least believe that the drawing I am putting here is consistent with the code. You had a question?

Student:Yeah. [Inaudible].

Instructor (Jerry Cain):Yeah, that pupil is three dot name. So this right here, the name field - it is not ampersand of name. So I do not pass the address of this box. I have pupil of three dot name evaluate itself. Okay? So if this is the number one,zerozerozero in here, it is because the address of that box right there is really a one,zerozerozero. And that is what passed as strcpy. So it starts copying characters to address one,zerozerozero, and then one,zerozeroone, one,zerozerotwo, etcetera. Does that make sense? Okay? Question in the back? No. Okay, you guys are good. One of the thing I - yep, right there.

Student:Look at variables in the string. What happens [inaudible]?

Instructor (Jerry Cain):If I - this right here, before this block ends, unless I want to pretend that atom is a helium balloon, and I want it to fly off and never be recovered, I would have to free it before this code block. And I could just do that by passing pupils of two dot name to free. Okay, free is the C equivalent of this delete thing you are familiar with. Okay?

Student:It does not really tell us [inaudible]? Teacher:

Nope, not at all. That is Java. That is not C plus  plus . Okay. One of the line pupils of seven dot SUID of twelve - let is not do that; let is do eleven - is equal to the character A. Just because there are structs involved does not mean that it intimidates the executable. It will go ahead and it will do the manual pointer arithmetic to find out where the seventh student would reside if this address, if the array actually existed there. So I would go to not the zeroth, the oneth, second, or third. I better go to the fourth, the fifth, the sixth, the seventh. There is a gesture, a little phantom halo, around the space that we are identifying, or pretending, these pupils of seven. Then I jump to its SUID field. That would reside and begin right here. As if I legitimately had space for eight characters right there. It even double whammies the system and goes beyond that array boundary. This is four - I am sorry, this is zero. This is four. This is eight, nine, ten, eleven. It would write this scattered A, sixty-five, in that one little byte over there in memory. Would it succeed while it is running? If it crashes, no. If it does not, yes. Okay? That is just the way it will work out. Okay? Does that make sense to people? If I were to go ahead, and I were to print in this state right here, if I were to print just the address itself, all I know is that the other three bytes are uninitialized. If I print this entire number, okay, all I can tell is that it would be less than two to the twenty-fourth. That is all I know because I zeroed out the really large contribution to the overall thing. Does that make sense? Okay. If I were to print out this right there, if I were to pass that CAR star, it has no idea that it is the address of a character that happens to be in larger string that starts before it, so if I were to pass that address to cout <<, it would print one XX, and that is it. Does that make sense? Okay. Just to make that clear to everybody. No boards. Here is - let is just say it is a dynamically allocated string that has Colleen backslash zero in it. Okay? If I pass that address to cout, it prints out the entire name Colleen. If I use my pointer tricks to pass that to cout <<, it still begins a null terminated string. It happens to not mean as much to us, but it will still print it out textually. It would print out L-L-E-E-N. Okay? If I pass that right there, it would print out E-N. If I pass that, it would just print nothing because it does not actually print the backslash zero. So that is basically this weird representation of the empty string. Okay? Does that make sense to people? Okay. Very good. Okay. You guys are doing okay? Good. What I wanna do now, is I wanna start talking about how to write generics in C. We have enough experience with this memory business so that I can actually write a real function in C that leverages off of this stuff. Let me just write a function I know you have seen before, and it is actually charmingly simple for us to go out because this is all very difficult compared to what I am about to write. Actually, this board is better. I want to just write a really simple function, and use advanced memory terminology to describe what happens. Void swap int star - actually, you probably have not seen this version before if you have used references in the past.

What happens is that you have probably declared two integers, X seven, int Very good. Okay. You guys are doing okay? Good. What I wanna do now, is I wanna start talking about how to write generics in C. We have enough experience with this memory business so that I can actually write a real function in C that leverages off of this stuff. Let me just write a function I know you have seen before, and it is actually charmingly simple for us to go out because this is all very difficult compared to what I am about to write. Actually, this board is better. I want to just write a really simple function, and use advanced memory terminology to describe what happens. Void swap int star - actually, you probably have not seen this version before if you have used references in the past. What happens is that you have probably declared two integers, X seven; int Y is equal to one hundred and seventeen. And I am concerned with the call to swap, where I pass in the locations of my X and Y variables. C - and I am writing up here. C function right here has no templates. That is relevant. It also has no references. Okay? So there are few meanings - fewer meanings of the ampersand symbol in C. What I am doing here is I am assuming I own X and Y as little jewel boxes, and I pass the addresses of those to the sway function so it knows, at least, where to go to move byte patterns around. That is effectively what is done by the swap when you think about it memory terms. Okay? Does that make sense? So this is a function I have not written yet, but I know that this thing called AP and BP - the P is there for just to remind myself that it is a pointer - this points to the X box and the Y box that has a one hundred and seventeen in it. So what I want to do is I want to exchange the one - I am sorry, the seven in the seventeen. The way I do this is I declare a tenth variable, and set it equal to what I get by traveling from the AP pointer to the space it addresses. So I get temp right there. How is it initialized? It is not set to this number. The asterisk says please hop forward once to find the place that should be copied. The bit pattern for that seven is replicated right there. Because tenth and the space addressed by AP are both ints, the bit patterns mean the same thing in both contexts. Then I do this. A little bit more involved, but you understand, certainly, what is going to happen. You may not - if I wrote a more difficult version of this type of function, it might not get it. But what happens here is the space addressed by AP - not this space right here, but the space addressed by it - is identified as the L value, or the recipient of whatever the right-hand side evaluates to. The right-hand side evaluates not to BP, but to what it addresses. Okay?

So this one hundred and seventeen is replicated right there. The four-byte representation of one hundred and seventeen is replicated in the space addressed by AP, and then finally I do this. BP addresses whatever was stored here previously. And that is how I get a seven right there. Let is get a better seven. Okay? Now, what I did there, algorithmically, had very little to do with ints. The only part of the fact that - the only fact about ints that was involved was that the figure is being rotated and swapped for four bytes. Okay? Make X and Y floats. Make this float star and float star, and make that a float. The pictures can even stay the same in terms of the drawings - in terms of the sizes. They are still four bytes, and as long as I exchange all these things, okay, then I am going to effectively achieve the swap, even though I do not necessarily care that they were floats versus integers. Okay? If I pass in double stars, or CAR stars, or bowl stars, or struct student stars, the same rules apply. Okay? It is bit pattern swapping is what it is - what it really is. Okay? You know enough about generics from CSone hundred and six PM, one hundred and sixX to know that we would probably use references - because references are prettier, right - from this point forward. And we would also templatize it if we wanted the same block of code that we write to be used in different type scenarios. We have neither one of those in pure C. But there are several situations where you do benefit by actually going the extra mile and making the code you write generic. Okay? Well, it is not pretty. Turns out it is actually kind of - it is something of a hack to write a generic function in C, but it is the way it is done. And once you understand memory really well, you stop thinking of it as a hack, and you start to see it as very, very beautiful. Okay? As the way it actually works - because you understand what is happening on your behalf when you swap these two figures - and you just specify the addresses. Or you linear search this array, and the algorithm for linear search is the same whether or not ints or strings or struct students are involved. Binary search the same way. Merge sort, quick sort, all those things you learned about, and templatize, in one hundred and sixB still can be done in languages older than C plus  plus  using this information about memory that we have learned over the last two lectures. Okay? So come Wednesday, I will go generic on you with this function right here. And frame it in terms of generic pointers and generic byte swappers. Okay? Have a good night.

[End of Audio]

Duration: fifty-three minutes



