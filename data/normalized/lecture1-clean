Programming Paradigm Lecture zero one Instructor (Jerry Cain):For two hundred and forty, now there will not be. Student:I can sit in [inaudible].

Instructor (Jerry Cain):Oh, that is fine. Hey, everyone, welcome, we are live on television. So this is cs one hundred and seven. My name is Jerry Cain. I have two handouts for you today. They are the type of handouts that you expect to get on the first day of a course. As far as pertinent information about myself; my life synopsis is on the board right here. There is my email address, those are my office hours, and that is my office upstairs, just more or less, directly above this room. By far, the best way to get in touch with me is email via that address. Certainly if you have a question that you need to ask me specifically about then email is great, I am very good about checking email. I am the type of person that just clicks on send and receive every three seconds, so I know when your email comes in so I am always very good about responding. The office hours are early in the mornings on Mondays and Wednesday, I know that is not the best time in the world, but just for various reasons, that is the only time I can really have them, but in general, if I am in my office you are more than welcome to stop by and you are always welcome to call my office to see if I am in during some other time in the week. Okay. I will try to make it a point to just casually be around the office as much as possible, but Monday and Wednesday, nine:zerozero to ten:thirty, is really the official time when I am around. Okay. I have a good number of staff members; I can have them just wave, you do not need to stand up, just wave, you can wave a little bit more enthusiastically, thank you. Okay. That actually only represents about a third of what the staff will be. Some people have a conflict today so they are not here. And I actually only figured out last night how large this class is. We expected a one hundred and thirty - one hundred and forty students and I just checked at ten:fifty-five that we have two hundred and forty-one signed up for the course, which is the largest that csone hundred and seven has ever been. It is really weird having this many people come and take and interest and listen when you talk.

I feel a little bit like Barack Obama. I am delighted that this many people are taking it and so I certainly expect to have, on the order of fifteen to eighteen TAs and undergraduate section leaders working and they are very pertinent to the course. I almost require - in fact, it is the case this quarter, that every single person I am gonna hire has taken one hundred and seven either as a undergraduate or as a first year graduate student, so they are great resources for questions and their office hours, with very little exception, they have all done all the various assignments that you will be doing this quarter, so they already know what your questions are gonna be. Okay. As far as their office hours are concerned, they will have office hours and they will rotate through a grid of evening hours at the main computer cluster where you will be expected, or at least invited, to do all of your online programming work. Okay. Those will start next week. You are not gonna have an assignment until this Friday, and I make that one as easy as possible as far as the coding assignment is concerned because you have to get used to Unix and this new development environment. A lot of you have probably never been there before, so I go soft on your on assignment one so you can actually not be intimidated by the whole Unix development process. We do have a discussion section. We had scheduled one for tomorrow - I am not even gonna say the time because I do not want to confuse people - but it turned out that it was terrible for three of my four head TAs so I am in the process of rescheduling that. It is not gonna be on Thursday, it is probably gonna be on Tuesdays. That is what I am shooting for now. At the time I had to take these handouts to press I just did not have a time yet, but I will announce, certainly in lecture on Friday and probably prior to that via the emailing list. You are not required to go to discussion session, it is gonna be televised just like the lectures are - there will always be section handouts and section solutions, so even if you just do not want to bother watching it, not that I am recommending that, but you certainly have the resources to figure out what they went over during that section because I will be very good about putting up section handouts and section solutions so you know exactly what topics they were discussing. Okay. Whatever the time is next week, it will probably be Tuesday sometime in the afternoon.

The first section, if you go to one section off quarter and go to one live section off quarter, next weeks is probably the one to go to if you have never really dealt with Unix before. They will invest some energy coming up with some slides and some examples to show you what it is like to open an [inaudible] in Emax and to actually code there and then to use a command line to compile the program and see how you actually compile and execute and debug programs in a Unix world. Okay. And it is a little weird at first, you kind of hate it for three or four days then you start to like it because it is really light weight and very fast. So that is another reason why I make the first assignment less about coding and more about just getting used to Unix. Okay. Not next week, but the week after when we start having discussion sessions again, and having more of them, that will adopt a more traditional format where we bring section problems and we talk and everybody raises their hand and asks questions and things like that. Okay. As far as reading material is concerned, in the handout I specify three books that I think are really great books. Two of them are on C plus  plus ; they are actually quite advanced books. There is also one book on a language called Scheme, which I will talk about in a second. These are by no means required and I do not even want to say that I recommend them in a sense that those who are really fastidious about going and buying every book they think is gonna help them, I am not really even saying that you should go buy it, I just want them to be on your radar so that if after you get through the C and C plus  segment of the course, you can see yourself doing more serious C plus  plus  programming later on, then you might want to go and get these book. But do not spend money on books yet because this class has more or less been taught with the same type of structure over the past fifteen years so we have compiled pages and pages of handouts. This is just the tip of the iceberg. Anything you are gonna be responsible for is covered either in lecture of in the handouts. I am not gonna have any external reading from text books so just worry about the handouts. The handouts are very polished. I think they are in really good shape. You will average one to two handouts every single lecture and probably Friday and Monday, you are gonna get four or five each day. As far as the exams are concerned - let me talk a little bit about that. Midterm, there is one, and it is Wednesday, May seven. Okay. I schedule it for seven:zerozero to ten:zerozero P.M. People roll their eyes when they see a three-hour window set aside for a midterm.

I am not gonna write the midterm with the intent of you needing every single minute of those three hours. I genuinely make an effort to make the exam so that it can be completed, patiently, in sixty to ninety minutes, okay, and occasionally, I am off. When that happens, you have this buffer of an extra hour and a half to really work through it. Okay. I just give people three hours with the intent of giving the illusion of an infinite amount of time so that they do not feel that they are pressured to get through it. That may sound like I am being really nice, but I am actually being slight cruel by giving you three hours because if you do badly on it, then you have one less reason to blame me. You actually have to work through the problems and you really have to know the material, and you cannot blame time pressure as being a factor as to why the exam did not go well. So that is why I want to give people as much time as I can reasonably give them without going into two:zerozero A.M., three:zerozero A.M. Okay. I recognize that because this is scheduled outside of lecture that many of you may have classes, orchestra meets at night, people have various activities they have to do at night, I want to displace you from those because I decide to have my exam outside of lecture so if you cannot make that time, that is fine, just let me know soon and plan on taking the exam during some three hour window that fits between ten:zerozero A.M. and six:zerozero P.M. Okay. So most people that works with. If that is not gonna work out, then let me know now. I will make sure you take the exam sometime, but I will be around more or less or TAs will be more or less all day Wednesday to make sure that you can take an exam when you need to. I will accommodate any reasonable requests. As far as the final is concerned, I offer the final exam twice. Our dedicated slot is Monday, June nine and the official time is eight:thirty A.M. Now, because we are on TV and because Stanford students - there is just not that many times to offer classes, a lot of people have conflicts, a lot of people are taking two classes, sometimes even three classes Monday, Wednesday, Friday at eleven:zerozero, and if that is the case, then you have two or three finals on Monday, June nineth at eight:thirty. If you want to take all three then, you are more than welcome to, but I assume you are not gonna want to do that so if you cannot make this time, it is fine, provided you can make an alternate slot of three:thirty P.M. that day. If you cannot make either of those times, please let me know now so I can take care of that.

As far as the breakdown of assignments versus exams, this is how it all pieces together in the end. You have assignments, you have the midterm, you have the final, these contribute forty percent of your grade. The midterm is the least of the three and the rest is the final. Okay. That is a pretty sizable chunk is dedicated to the assignments. People, in general, do very well in the assignments. They might struggle to figure out what kind of things we are expecting on assignment one, but eventually, people figure out what I am expecting and they get the programs to work and they write nice clean code, so we see a lot of A is and A-s on the programs. We just do. And I imagine eighty percent of you will be getting A is and A-s on some of the later programs because you will just start figuring things out. And that is not to say that grades will be much lower prior to that, but just toward the end everybody seems to be doing very well on the assignments. There is probably gonna be six or seven assignments. One of them will not be handed in, it will be a written problem set where the deadline will, more or less, be at the time you take the midterm because it will be a series of written problems that serve as practice for the midterm. You are certainly responsible for that, but all the other assignments take a programming assignment approach where you actually code up stuff and you electronically submit it and one of the section leaders or the TAs grade your work and they electronically or they email you back feedback. I do not need any paper copies at all. Everything is dealt with electronically. We are gonna really put a lot of effort into trying to turn the assignments around very, very quickly. In order to do that, I do allow you to turn work in late. I have the same type of late day policy that one hundred and sixb does.

I actually give you the ability to grant yourself little extensions in twenty-four-hour units. I give you five of those little days. And if you want, you can use one or two or all five later days on any particular assignment, but after five days, whether using free late days or extra ones that actually cost you a little bit, I need all the assignments within five days of the deadline so that I know that the TAs can start grading them and crank out grades and crank out feedback and get them back to you. Does that all make sense to everybody? Okay. As far as the midterm or final will go I actually try to make this - I do not want to say that I make it easy, I think, of the two exams, the final is a little bit more difficult because I think the midterm actually deals with the more difficult material so I go soft on you here knowing that I am gonna revisit some of that material on the final. Okay. Now, when I say, "Soft," I do not mean easy, I just meant softer, comparative. Okay. Then I would normally go, but nonetheless, that is why I have the breakdown of twenty-five to thirty-five - really, all the material is equally represented on the final exam. I am trying to think what else is going on. Oh, of course, as far as resources for keeping in touch with us, if you have a question specifically for me, then by all means email that address right there, but if you are asking a question about an assignment or lecture material that you know or suspect any section leader or TA would be able to answer, then you are gonna benefit by sending mail to this address. Csone hundred and seven@cs.stanford.edu. That is precisely the address that you would assume would be attached to a staff emailing list for this class. When you do that, you are sending mail to an account that all fifteen or eighteen or nineteen of us whole on a fairly regular basis and so you are that much more likely to get a quick response. Maybe not so much on a Saturday morning, but certainly on a weeknight when everybody is coding and deadlines are approaching. We are very good about pulling that and getting responses out as quickly as possible. Okay. If you do not hear back from this within, like say, twelve or twenty-four hours - let is say twelve hours in a weekday and twenty-four hours on the weekend, then it is okay to email me directly and say, "Hey, I am not getting my answers, can you answer this question for me?" But be patient with that. We are actually very good - very often, we get back to people within minutes. A lot of times the TAs are sitting in front of the computer right next to you in the term or cluster where you are working, you just do not know what they look like so they respond to your question very, very quickly. I am also gonna try to experiment - I have no idea what I am planning to do with this, but I have a Facebook group. The URL is for csone hundred and seven - the URL is in the handout. You do have to be a member of Facebook.

I am not trying to evangelist Facebook just because I work there as well, but if you have a Facebook account already and want to go join this Facebook group, just visit the URL that is posted in the handout or just do a search for csone hundred and seven and I am sure it will come up. I also have a Twitter account for one hundred and seven. If you want to follow csone hundred and seven - I think this is an interesting idea because I could send little announcements, these very lightweight, noninvasive announcements to everybody who is paying attention to csone hundred and seven on Twitter saying, "Webpage has been update or exam cancelled," or something like that. Okay. And you can all follow what is going on there. I do not want you to think that you have to pay attention to these. Anything that is truly important about assignment deadlines or things that need clarification, I will actually use the mailing list and post to it. That will be the official forum for things that really matter but these are intended to be lighthearted. As far as that mailing list is concerned, I have two hundred and forty-one people signed up for the course already. That means that most of you, if not all of you, are automatically enrolled in the mailing list for the course, so when I send mail to csone hundred and seven-sprzeroseven hundred and eight-students@list.stanford.edu, you automatically get that email provided you are registered for the class. If you have not registered for the class yet, let me pester you a little bit to go and sign up for the class even if you are not sure if you are gonna take it because, probably, I send more announcements in the first week of the course than I do anytime later on because just a lot has to happen and we have to up ramp a lot in the first few days so I am certainly gonna send an email out as soon as I found when section time is. A lot of you have signed up for the course may not realize this, but sometimes you can inadvertently set some privacy settings so that you are email is not put on that list - do you know what I am talking about? Okay. So go to Stanfordu.com or u.stanford.com, I forget what it is or wdu where you just go make sure that your email is public just to the Stanford community so that you can get on that emailing list. If you have a problem with that, I understand that you do not want your email address advertised, but then just make it a point to email me and say that you are not that so I can put your email address on some sub list that I always include with the announcements. Does that make sense to everybody? Let me just talk a little bit about the syllabus. Let is make sure there is nothing in here. Is there anyone in the room who has not taken one hundred and sixb or one hundred and sixx, a couple people I am assuming, okay. I am just taking a pulse on this. I do not necessarily require one hundred and sixx or one hundred and sixb, specifically, but I do kind of expect that you have done some C plus  plus  programming, that the notion of a linked list or a hash table is familiar to you, a binary search tree, a function point or all of those things that are covered in our one hundred and six courses are familiar to you. If that is not the case or you do not know C plus  plus  all that well, then I am a little worried because the first half of one hundred and seven is all about advanced C and C plus  plus , so if you do not have the basics down or you have not been exposed to that stuff yet, it makes the first two weeks of the course, which is normally actually quite fun because you are learning all about the inside, under the hood machinery of the C language, it can make it pretty miserable unless you actually anticipate spending a little bit more time getting up and running. So if you do not know C or C plus  plus  and you have never written an assignment for a course in C or C plus  plus  then talk to me after lecture so I can kind of gauge as to whether one hundred and sixb or one hundred and seven is better for you. Okay.

Here is, in a nutshell, a reduced version of what is presented in handout two. This is the syllabus. I have several languages that I am gonna put on the board and one concept. C, Assembly, C plus  plus , Concurrent programming - that is not a language, that is just a paradigm, Scheme and then it is official, I am actually gonna cover Python from now on in one hundred and seven. People look at this and they go, "Wow, I am gonna be able to legitimately put all of these languages on my resume," and it is from a separate list at the bottom and it feels really good. It is not so much about that. Certainly we want to give you some mileage in some very relevant languages that are very good for both research and for industry, but the real intellectual value in learning all of these languages is to really study the paradigms that they represent, and I will explain what that means in a second. I think a lot of C plus  plus  programmers really program in C and just incidentally use the objects within the classes that are available to them, okay, which is a perfectly reasonable way to program. Most people learned how to program in C, at least the people I know in the industry, know C very, very well, and in spite of the fact that there is fifty million newer languages that are better in many regards, they still stick with what they know and that is why C and C plus  plus  are still such popular languages. There is nothing wrong with programming in C if you know it very well and you write clean, readable code, it is just more difficult. I do not really care so much about teaching you how to program an assembly, I use it as a vehicle for showing you how C and C plus  plus  programs compile to dot zero and to object files and to binaries and that become executables and show you how a line like I  equals  seven or J plus  plus  or FU of X and Y is a function call, how that all translates to assembly code. Okay. Does that make sense? You know when you write C plus  plus  code that when you execute the program, it is not C plus  plus  anymore, it is assembly code. It is all zeros and ones eventually. I want to give you some insight as to how C is translated to assembly code, how all these variables and your functions and your objects and all of that, eventually, get boiled down and hashed down to a collection of zeros and ones and I want to do a little bit of the same thing for C plus  plus . It turns out that - well, C plus  plus  and C represent different paradigms, that they really compile the zeros and one, and after you get enough experience with this assembly and the manual compilation process that we are gonna learn about and how to look at C code and figure out what the assembly code would look like, you are really gonna see that C plus  plus  and C almost look like the same language as far as the zeros and ones are concerned. I am gonna be able to do something like  star  star  ampersand  star  star P arrow  star  star  star  equals seven and you are gonna know exactly what it means. Okay.

So it takes a little bit of work and it is almost laughable how arbitrary you can be with formulas, but if it compiles, it means something so when it runs it actually does something. It is probably not good if you have a lot of asterisks and ampersands, but nonetheless, you can have some idea as to why it is crushing, not just that it is crushing. Okay. I spend a good amount of energy talking about concurrent programming. We actually - at the moment, do that type of programming in C, but all the programs you have written in the past two quarters, if you have just taken the one hundred and sixA and one hundred and sixb courses here or one hundred and sixx, all the programs you have written at Stanford, prior to one hundred and seven, have been sequential programs. That means that whether it is object oriented or procedurally oriented, you have this outline of steps that happen one after another. Nothing is done in parallel or pipelined or done side-by-side, everything happens in one clean stream of instructions. Okay. Well, what concurrent programming is about is within a single program trying to get two functions to seemingly run simultaneously. If you can get two functions to seemingly run simultaneously then you can extend that and get ten functions to run simultaneously or twenty functions to run simultaneously or seemingly simultaneously. I say it that because, technically, they do not run at the same time. When I go over assembly code, and I think you can intuit enough about what assembly code is like, but if you have this one function, okay, my hand is a function, this hand is another function, okay and you concern yourself with the execution of one of them and then when I do this you can just think about it reading the code and executing it for side effects. Does that make sense to people? When you deal with concurrent programming you have two or more functions, just two right here because I only have two hands, to do this and they both seemingly run at the same time, but what really happens is it is like watching two movies at the same time where - because there is only one processor on those machines, it does not really run like this, it runs like this and switches back and forth between the two functions, but it happens so fast that you just cannot see the difference. Okay. It is more than twenty-four transfer seconds, it is, like, a million. There are a lot of situations where concurrent programming is not very useful, but there are several situations, particularly networking, whenever that is involved, where concurrent programming is actually very useful.

There are some problems that come up when you deal with concurrent programming that you might not think about. The example I always go over the first day of class is just that it uses two Wells Fargo ATM machines. Okay. Think about you have a Wells Fargo checking account, you may not have to think about it because you probably do, so just imagine your checking account is in danger because two people are using ATM machines and you have a  dollars one hundred in it and you share your PIN with your best friend and you go up to a neighboring ATM machines and you make as much progress as possible to withdraw that  dollars one hundred and then you both, on the count of three, press okay to try and get  dollars two hundred collected. Does that make sense? That is not a sense sensible example because both of those machines are basically very simple computers, okay, that ultimately need to access the same master account balance to confirm that  dollars one hundred is available and in this transactional - transactional makes sense both in terms of money and also in the sense of concurrent programming - you have to make sure that the  dollars one hundred, being identified as the account balance, is maintained with some atomic flavor so that if you have two people trying to withdraw  dollars one hundred at the same time that only one person gets away with it. That  dollars one hundred account balance is the shared resource that two different processes have access to. Does that make sense to people? Okay. So there has to be directives that are put in place to make sure that the account balance check and the withdrawal are basically done, either not at all, or in full so that it really does function, truly, as a transaction, both in the finance and the concurrent programming sense. Okay. As far as this Scheme and Python are concerned, once we get through concurrent programming we really switch gears and we start looking at this language called Scheme. You may not have heard of this. If you have not heard of this, you may have heard of a language called LISP, which it is certainly related to. This is a representative of what is called the functional paradigm. Okay. There is two things about Scheme and functional languages - purely functional languages that are interesting in contrast to C and C plus  plus . When you program using the functional paradigm you always rely on the return value of a function to move forward. Okay. And you program without side effects. Now, that is a very weird thing to hear as an expression when you have only coded for a year, but when you code in C and C plus  plus , it is very often all about side effects.

The return value does not always tell you very much. It is a number or it is a bouillon, but when you pass in a data structure by reference to a function and you update it so that when the function returns, the original data structure has been changed, right, does that make sense? That is programming by side effects. Well, the idea with Scheme and particularly the functional paradigm is that you do not program with side effects. You do not have that at all. You always synthesize the results or partial results that become larger partial results that eventually become the result that you are interested in and only then are you allowed to print it to the screen to see what the answer to the problem was. Okay. It is very difficult to explain Scheme if you have never seen it before in a five minute segment of a full introduction, but when you get there, we have tons of examples of the paradigm. It is a very fun, neat little language to work in. This language called Python - I am suspecting that most people have heard of it even if they have never seen it. It seems to be the rage language at a lot of significant companies in the Bay Area. They are very smart people with these companies so when they use a language and they like it, there is usually a very good reason for them liking it. You have probably heard of a language called Pearl. Okay. It is not a very pretty language. You can just think about, in some sense, Python being a more modern, object oriented version of Pearl. Okay. Now, if you do not know Pearl and you do not know Python it does not mean anything to you, but just understand that this sexy little language that is been around for probably sixteen, seventeen years that is really established itself as a popular language since year two thousand, two thousand and one. I know a lot of people who work at Google that program in Python on a daily basis. There is a subset of us at Facebook that program in Python every day. It actually has a lot of good libraries for dealing with web programming. Web programming can seem really boring to a lot of people because it just seems like it is just HTML and web pages and things like that. Real web programming is more sophisticated than that. You dynamically generate web pages based on content and databases and things like that and Python, being a scripting language, which means its interpretive and you can type in stuff as you go, it recognizes and reads and executes the stuff as you type, it is very good for that type of thing, and if all goes well, meaning I have time to develop this assignment idea I have, you are gonna write a little miniature dynamic web server in Python for your final project. It will not be that sophisticated. You are not gonna write all of apache, but you are gonna probably write some little thing where you really do have a web server behind the scenes making decisions about how to construct an HTML page and serve that over to a client. So it will be an opportunity to learn Python, to learn with libraries, to see that as a language because it is fairly young, it has the advantage of not bothering to include C and C plus  plus 's and Java is mistakes. It says, "No, I will leave that part out and I will go with this more interesting, well formed core," it has great libraries, it has object orientation, you can program procedurally if you want to and just program like you are in C, but using Python syntax.

There are even functional programming aspects in the language so even though the syntax is different from Scheme, conceptually, you can use Scheme like ideas in Python coding if you want to. Okay. I will be able to illustrate the client server paradigm and how it is different from traditional programming. That is not so much a Python thing, but Python is a good vehicle for learning that stuff. There are a few other paradigms that are not represented here, but I think I really cover all the ones that you are likely to see for the next fifteen years and you are a coder. Okay. There are a couple of the languages that I may briefly mention the last night that are just fun, but they all have some overlap with some languages represented right here. Okay. You guys are good? Okay. So I do not like starting in on any real material when I only have ten minutes left, so I am actually gonna let you go, but recognize that Friday I am gonna have tons of handouts for you, I am gonna have an assignment, okay, we are gonna dive right into the low level pointer stuff of C and C plus  plus . Okay. So have a good week.

[End of Audio]

Duration: thirty-seven minutes

